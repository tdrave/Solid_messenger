import '@ungap/global-this';

var TermType;
(function (TermType) {
    TermType["NamedNode"] = "NamedNode";
    TermType["BlankNode"] = "BlankNode";
    TermType["Literal"] = "Literal";
})(TermType || (TermType = {}));
var QuadPosition;
(function (QuadPosition) {
    QuadPosition[QuadPosition["subject"] = 0] = "subject";
    QuadPosition[QuadPosition["predicate"] = 1] = "predicate";
    QuadPosition[QuadPosition["object"] = 2] = "object";
    QuadPosition[QuadPosition["graph"] = 3] = "graph";
})(QuadPosition || (QuadPosition = {}));
var Feature;
(function (Feature) {
    /** Whether the factory supports termType:Collection terms */
    Feature["collections"] = "COLLECTIONS";
    /** Whether the factory supports termType:DefaultGraph terms */
    Feature["defaultGraphType"] = "DEFAULT_GRAPH_TYPE";
    /** Whether the factory supports equals on produced instances */
    Feature["equalsMethod"] = "EQUALS_METHOD";
    /** Whether the factory can create a unique idempotent identifier for the given term. */
    Feature["id"] = "ID";
    /** Whether the factory stores its unique idempotent identifier for the given term on the instance with the `id` property (implies Feature.id). */
    Feature["idStamp"] = "ID_STAMP";
    /** Whether the factory will return the same instance for subsequent calls (implies implies Feature.id and `===`). */
    Feature["identity"] = "IDENTITY";
    /** Whether the factory supports mapping ids back to instances (should adhere to the identity setting) */
    Feature["reversibleId"] = "REVERSIBLE_ID";
    /** Whether the factory supports termType:Variable terms */
    Feature["variableType"] = "VARIABLE_TYPE";
})(Feature || (Feature = {}));

const datatypes = {
    boolean: "http://www.w3.org/2001/XMLSchema#boolean",
    dateTime: "http://www.w3.org/2001/XMLSchema#dateTime",
    double: "http://www.w3.org/2001/XMLSchema#double",
    decimal: "http://www.w3.org/2001/XMLSchema#decimal",
    integer: "http://www.w3.org/2001/XMLSchema#integer",
    langString: "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString",
    string: "http://www.w3.org/2001/XMLSchema#string",
};
function equals(a, b) {
    if (a === b) {
        return true;
    }
    if (!a || !b) {
        return a === b;
    }
    if (Array.isArray(a) || Array.isArray(b)) {
        if (!(Array.isArray(a) && Array.isArray(b))) {
            return false;
        }
        return equals(a[0], b[0])
            && equals(a[1], b[1])
            && equals(a[2], b[2])
            && equals(a[3], b[3]);
    }
    if (PlainFactory.isQuad(a) || PlainFactory.isQuad(b)) {
        if (!PlainFactory.isQuad(a) || !PlainFactory.isQuad(b)) {
            return false;
        }
        return equals(a.subject, b.subject)
            && equals(a.predicate, b.predicate)
            && equals(a.object, b.object)
            && equals(a.graph, b.graph);
    }
    switch (a.termType) {
        case 'Literal': {
            return a.termType === b.termType
                && a.value === b.value
                && b.datatype === b.datatype
                && b.language === b.language;
        }
        default:
            if (!a.termType || !b.termType) {
                return false;
            }
            return a.termType === b.termType
                && a.value === b.value;
    }
}
const RDFBase = {
    equals(other) {
        return equals(this, other);
    },
    /* rdflib compat */
    toCanonical() {
        return this;
    },
};
/**
 * Plain JS/functional implementation of the RDF/JS: Data model specification, limited to a strict
 * rdf subset (no Variable, no Literal as predicate, etc.).
 */
class PlainFactory {
    constructor(opts = {}) {
        this.bnIndex = opts.bnIndex || 0;
        this.supports = opts.supports || {
            [Feature.collections]: false,
            [Feature.defaultGraphType]: false,
            [Feature.equalsMethod]: false,
            [Feature.id]: true,
            [Feature.idStamp]: false,
            [Feature.identity]: false,
            [Feature.reversibleId]: true,
            [Feature.variableType]: false,
        };
    }
    /**
     * Checks if the object {obj} is a Quad.
     */
    static isQuad(obj) {
        if (Array.isArray(obj) || typeof obj !== "object" || obj === null) {
            return false;
        }
        return !!("subject" in obj
            && "predicate" in obj
            && "object" in obj);
    }
    namedNode(value) {
        const term = Object.create(RDFBase);
        term.termType = TermType.NamedNode;
        term.value = value;
        return term;
    }
    blankNode(value) {
        const term = Object.create(RDFBase);
        term.termType = TermType.BlankNode;
        term.value = value || `b${++this.bnIndex}`;
        return term;
    }
    literal(value, languageOrDatatype) {
        if (typeof value !== "string") {
            return this.parseLiteral(value);
        }
        const term = Object.create(RDFBase);
        term.termType = TermType.Literal;
        // Perf: Always set all properties to prevent the creation of unnecessary HiddenClass objects.
        term.language = typeof languageOrDatatype === "string" ? languageOrDatatype : undefined;
        term.datatype = typeof languageOrDatatype === "string"
            ? this.namedNode(datatypes.langString)
            : languageOrDatatype || this.namedNode(datatypes.string);
        term.value = value;
        return term;
    }
    defaultGraph() {
        return this.namedNode("rdf:defaultGraph");
    }
    /**
     * Create an RDF statement in object form.
     * @param subject The subject of the statement
     * @param predicate The predicate of the statement
     * @param object The object of the statement
     * @param graph The graph of the statement
     */
    quad(subject, predicate, object, graph) {
        return {
            subject,
            predicate,
            object,
            graph: graph || this.defaultGraph()
        };
    }
    isQuad(obj) {
        return PlainFactory.isQuad(obj);
    }
    /**
     * * Returns an RDF statement in array form.
     * @param subject The subject of the statement
     * @param predicate The predicate of the statement
     * @param object The object of the statement
     * @param graph The graph of the statement
     */
    quadruple(subject, predicate, object, graph) {
        return [
            subject,
            predicate,
            object,
            graph || this.defaultGraph(),
        ];
    }
    fromTerm(original) {
        if (original.termType === "Literal") {
            return this.literal(original.value, original.language || original.datatype);
        }
        return {
            termType: original.termType,
            value: original.value,
        };
    }
    fromQuad(original) {
        return {
            subject: original.subject,
            predicate: original.predicate,
            object: original.object,
            graph: original.graph || this.defaultGraph(),
        };
    }
    fromQdr(original) {
        return {
            subject: original[0],
            predicate: original[1],
            object: original[2],
            graph: original[3] || this.defaultGraph(),
        };
    }
    qdrFromQuad(original) {
        return [
            original.subject,
            original.predicate,
            original.object,
            original.graph || this.defaultGraph(),
        ];
    }
    qdrFromQdr(original) {
        return [
            original[0],
            original[1],
            original[2],
            original[3] || this.defaultGraph(),
        ];
    }
    /**
     * Compare if two RDF objects are the same.
     *
     * Should work with non-standard rdf libraries as well (e.g. supporting Variable and Collection).
     */
    equals(a, b) {
        return equals(a, b);
    }
    fromId(id) {
        return this.termFromNQ(id);
    }
    id(obj) {
        return this.toNQ(obj);
    }
    termFromNQ(nq) {
        if (nq.startsWith("<")) {
            return this.namedNode(nq.slice("<".length, -1));
        }
        else if (nq.startsWith("_")) {
            return this.blankNode(nq.slice("_:".length, -1));
        }
        else if (nq.startsWith('"')) {
            const [valueOrLang, datatype] = nq.split("^^");
            const [value, lang] = valueOrLang.split("@");
            return this.literal(value.slice(1, -1), lang || (datatype ? this.namedNode(datatype) : undefined));
        }
        else {
            throw new Error("Unknown term given");
        }
    }
    toNQ(term) {
        if (Array.isArray(term)) {
            const graph = term[3] === this.defaultGraph() ? '' : (this.toNQ(term[3]) + ' ');
            return `${this.toNQ(term[0])} ${this.toNQ(term[1])} ${this.toNQ(term[2])} ${graph}.`;
        }
        else if (this.isQuad(term)) {
            return this.quadToNQ(term);
        }
        return this.termToNQ(term);
    }
    parseLiteral(value) {
        let literalValue = undefined;
        let datatype = undefined;
        if (typeof value === "number" || value instanceof Number) {
            // From rdflib; https://github.com/linkeddata/rdflib.js/blob/master/src/literal.js#L104
            if (value.toString().indexOf('e') < 0 && Math.ceil(value) <= Number.MAX_SAFE_INTEGER) {
                datatype = Number.isInteger(value) ? datatypes.integer : datatypes.decimal;
            }
            else {
                datatype = datatypes.double;
            }
            literalValue = value.toString();
        }
        else if (typeof value === "boolean" || value instanceof Boolean) {
            literalValue = value.toString();
            datatype = datatypes.boolean;
        }
        else if (typeof value === "bigint") {
            datatype = datatypes.integer;
            literalValue = value.toString();
        }
        else if (typeof value === "object") {
            if (value instanceof Date) {
                if (isNaN(value.getTime())) {
                    throw new Error('Invalid date given');
                }
                literalValue = value.toISOString();
                datatype = datatypes.dateTime;
            }
        }
        if (typeof datatype !== "undefined") {
            return this.literal(literalValue, this.namedNode(datatype));
        }
        throw new Error(`Can't parse value '${value}'`);
    }
    termToNQ(term) {
        switch (term.termType) {
            case TermType.BlankNode:
                return `_:${term.value}`;
            case TermType.NamedNode:
                return `<${term.value}>`;
            case TermType.Literal:
                const escaped = `"${term.value.replace(/([\n"\\\r])/g, (match) => {
                    switch (match) {
                        case "\n": return "\\n";
                        case "\r": return "\\r";
                        case "\"": return "\\\"";
                        case "\\": return "\\\\";
                        default: return match;
                    }
                })}"`;
                if (term.datatype) {
                    if (term.datatype.value === datatypes.string) {
                        return escaped;
                    }
                    return `${escaped}^^${this.termToNQ(term.datatype)}`;
                }
                if (term.language) {
                    return `${escaped}@${term.language}`;
                }
                return escaped;
            default:
                throw new Error(`Nonstandard termtype '${term.termType}' given`);
        }
    }
    quadrupleToNQ(quad) {
        const graph = !quad[QuadPosition.graph] || quad[QuadPosition.graph] === this.defaultGraph()
            ? ''
            : (this.toNQ(quad[QuadPosition.graph]) + ' ');
        return `${this.toNQ(quad[QuadPosition.subject])} ${this.toNQ(quad[QuadPosition.predicate])} ${this.toNQ(quad[QuadPosition.object])} ${graph}.\n`;
    }
    quadToNQ(quad) {
        return this.quadrupleToNQ([
            quad.subject,
            quad.predicate,
            quad.object,
            quad.graph || this.defaultGraph(),
        ]);
    }
}
/**
 * Plain JS/functional implementation of the RDF/JS: Data model specification, limited to a strict
 * rdf subset (no Variable, no Literal as predicate, etc.).
 */
const DefaultFactory = new PlainFactory();

function isTerm(obj) {
    return typeof obj === "object" && obj !== null && "termType" in obj;
}
function isNamedNode(obj) {
    return isTerm(obj) && obj.termType === TermType.NamedNode;
}
function isBlankNode(obj) {
    return isTerm(obj) && obj.termType === TermType.BlankNode;
}
function isLiteral(obj) {
    return isTerm(obj) && obj.termType === TermType.Literal;
}
const TermTypes = [
    TermType.NamedNode.toString(),
    TermType.BlankNode.toString(),
    TermType.Literal.toString()
];
function isSomeTerm(obj) {
    return isTerm(obj) && TermTypes.includes(obj.termType) === true;
}
const NodeTypes = [TermType.NamedNode.toString(), TermType.BlankNode.toString()];
function isNode(obj) {
    return isTerm(obj) && NodeTypes.includes(obj.termType) === true;
}
function isQuad(obj) {
    return typeof obj === "object" && obj !== null && "subject" in obj;
}
function doc(node) {
    if (node.value.indexOf('#') < 0) {
        return node.value;
    }
    else {
        return node.value.split('#')[0];
    }
}

let setup;
let globalFactory;
let globalSymbol;
function shouldOverride(rdfFactory, override) {
    const factory = globalThis[rdfFactory];
    return typeof factory === "undefined" || factory === DefaultFactory || override;
}
function changeFactory(rdfFactory, factory, override) {
    if (shouldOverride(rdfFactory, override)) {
        globalThis[rdfFactory] = factory;
        globalFactory = factory;
    }
    else if (typeof globalFactory === "undefined" || override) {
        globalThis[rdfFactory] = factory;
        globalFactory = factory;
    }
}
if (typeof Symbol !== "undefined") {
    const rdfFactory = Symbol.for('rdfFactory');
    setup = function setup(factory = DefaultFactory, override = true) {
        changeFactory(rdfFactory, factory, override);
        globalFactory = globalThis[rdfFactory];
    };
    globalSymbol = rdfFactory;
}
else {
    const rdfFactory = 'rdfFactory';
    setup = function setup(factory = DefaultFactory, override = true) {
        changeFactory(rdfFactory, factory, override);
    };
    globalSymbol = rdfFactory;
    globalFactory = globalThis[rdfFactory];
}
setup(DefaultFactory);
const createNS = (ns) => (term) => globalFactory.namedNode(`${ns}${term}`);
let proxy;
if (typeof Proxy !== "undefined") {
    proxy = new Proxy(globalFactory || {}, {
        ownKeys() {
            return globalFactory && Object.keys(globalFactory) || [];
        },
        getOwnPropertyDescriptor(_, k) {
            return Object.getOwnPropertyDescriptor(globalFactory, k);
        },
        set(_, property, value) {
            globalFactory[property] = value;
            return true;
        },
        get(_, property) {
            return globalFactory[property];
        },
    });
}
else {
    proxy = [
        'namedNode',
        'blankNode',
        'literal',
        'defaultGraph',
        'quad',
        'quadruple',
        'fromTerm',
        'fromQuad',
        'fromQdr',
        'qdrFromQuad',
        'qdrFromQdr',
        'equals',
        'id',
        'toNQ',
        'fromId',
        'termToNQ',
        'termFromNQ',
        'quadrupleToNQ',
        'quadToNQ',
        'supports',
    ].reduce((acc, key) => {
        acc[key] = (...args) => globalFactory[key](...args);
        return acc;
    }, {});
}
var proxy$1 = proxy;

export default proxy$1;
export { Feature, PlainFactory, QuadPosition, TermType, createNS, doc, globalFactory, globalSymbol, isBlankNode, isLiteral, isNamedNode, isNode, isQuad, isSomeTerm, isTerm, setup };
//# sourceMappingURL=index.js.map
