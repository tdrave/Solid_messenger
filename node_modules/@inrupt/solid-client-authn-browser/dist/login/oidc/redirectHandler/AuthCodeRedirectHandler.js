"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthCodeRedirectHandler = exports.DEFAULT_LIFESPAN = void 0;
const solid_client_authn_core_1 = require("@inrupt/solid-client-authn-core");
const oidc_client_ext_1 = require("@inrupt/oidc-client-ext");
exports.DEFAULT_LIFESPAN = 30 * 60 * 1000;
async function setupResourceServerSession(webId, authenticatedFetch, storageUtility) {
    const webIdAsUrl = new URL(webId);
    const resourceServerIri = webIdAsUrl.origin;
    await authenticatedFetch(webId);
    try {
        const resourceServerResponse = await authenticatedFetch(`${resourceServerIri}/session`);
        if (resourceServerResponse.status === 200) {
            await storageUtility.storeResourceServerSessionInfo(webId, resourceServerIri, Date.now() + exports.DEFAULT_LIFESPAN);
            return;
        }
        await storageUtility.clearResourceServerSessionInfo(resourceServerIri);
    }
    catch (_e) {
        await storageUtility.clearResourceServerSessionInfo(resourceServerIri);
    }
}
class AuthCodeRedirectHandler {
    constructor(storageUtility, sessionInfoManager, issuerConfigFetcher, clientRegistrar, tokerRefresher) {
        this.storageUtility = storageUtility;
        this.sessionInfoManager = sessionInfoManager;
        this.issuerConfigFetcher = issuerConfigFetcher;
        this.clientRegistrar = clientRegistrar;
        this.tokerRefresher = tokerRefresher;
    }
    async canHandle(redirectUrl) {
        try {
            const myUrl = new URL(redirectUrl);
            return (myUrl.searchParams.get("code") !== null &&
                myUrl.searchParams.get("state") !== null);
        }
        catch (e) {
            throw new Error(`[${redirectUrl}] is not a valid URL, and cannot be used as a redirect URL: ${e}`);
        }
    }
    async handle(redirectUrl, eventEmitter) {
        if (!(await this.canHandle(redirectUrl))) {
            throw new Error(`AuthCodeRedirectHandler cannot handle [${redirectUrl}]: it is missing one of [code, state].`);
        }
        const url = new URL(redirectUrl);
        const oauthState = url.searchParams.get("state");
        const storedSessionId = (await this.storageUtility.getForUser(oauthState, "sessionId", {
            errorIfNull: true,
        }));
        const { issuerConfig, codeVerifier, redirectUrl: storedRedirectIri, dpop: isDpop, } = await (0, solid_client_authn_core_1.loadOidcContextFromStorage)(storedSessionId, this.storageUtility, this.issuerConfigFetcher);
        if (codeVerifier === undefined) {
            throw new Error(`The code verifier for session ${storedSessionId} is missing from storage.`);
        }
        if (storedRedirectIri === undefined) {
            throw new Error(`The redirect URL for session ${storedSessionId} is missing from storage.`);
        }
        const client = await this.clientRegistrar.getClient({ sessionId: storedSessionId }, issuerConfig);
        let tokens;
        const tokenCreatedAt = Date.now();
        if (isDpop) {
            tokens = await (0, oidc_client_ext_1.getDpopToken)(issuerConfig, client, {
                grantType: "authorization_code",
                code: url.searchParams.get("code"),
                codeVerifier,
                redirectUrl: storedRedirectIri,
            });
            window.localStorage.removeItem(`oidc.${oauthState}`);
        }
        else {
            tokens = await (0, oidc_client_ext_1.getBearerToken)(url.toString());
        }
        let refreshOptions;
        if (tokens.refreshToken !== undefined) {
            refreshOptions = {
                sessionId: storedSessionId,
                refreshToken: tokens.refreshToken,
                tokenRefresher: this.tokerRefresher,
            };
        }
        const authFetch = await (0, solid_client_authn_core_1.buildAuthenticatedFetch)(fetch, tokens.accessToken, {
            dpopKey: tokens.dpopKey,
            refreshOptions,
            eventEmitter,
            expiresIn: tokens.expiresIn,
        });
        await this.storageUtility.setForUser(storedSessionId, {
            webId: tokens.webId,
            isLoggedIn: "true",
        }, { secure: true });
        url.searchParams.delete("code");
        await this.storageUtility.setForUser(storedSessionId, {
            redirectUrl: url.toString(),
        }, {
            secure: false,
        });
        const essWorkaroundDisabled = window.localStorage.getItem("tmp-resource-server-session-enabled") ===
            "false";
        if (!essWorkaroundDisabled) {
            await setupResourceServerSession(tokens.webId, authFetch, this.storageUtility);
        }
        const sessionInfo = await this.sessionInfoManager.get(storedSessionId);
        if (!sessionInfo) {
            throw new Error(`Could not retrieve session: [${storedSessionId}].`);
        }
        return Object.assign(sessionInfo, {
            fetch: authFetch,
            expirationDate: typeof tokens.expiresIn === "number"
                ? tokenCreatedAt + tokens.expiresIn * 1000
                : null,
        });
    }
}
exports.AuthCodeRedirectHandler = AuthCodeRedirectHandler;
//# sourceMappingURL=AuthCodeRedirectHandler.js.map