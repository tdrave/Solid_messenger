{"id":"node_modules/@inrupt/solid-client-authn-core/dist/login/oidc/redirectHandler/IRedirectHandler.js","dependencies":[{"name":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-core/dist/login/oidc/redirectHandler/IRedirectHandler.js.map","includedInParent":true,"mtime":1652099631152},{"name":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-core/src/login/oidc/redirectHandler/IRedirectHandler.ts","includedInParent":true,"mtime":1652099631237},{"name":"/Users/tdrave/demo-solid-app/package.json","includedInParent":true,"mtime":1652099771977},{"name":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-core/package.json","includedInParent":true,"mtime":1652099631124},{"name":"cross-fetch","loc":{"line":4,"column":30,"index":170},"parent":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-core/dist/login/oidc/redirectHandler/IRedirectHandler.js","resolved":"/Users/tdrave/demo-solid-app/node_modules/cross-fetch/dist/browser-ponyfill.js"},{"name":"jose","loc":{"line":5,"column":23,"index":209},"parent":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-core/dist/login/oidc/redirectHandler/IRedirectHandler.js","resolved":"/Users/tdrave/demo-solid-app/node_modules/jose/dist/browser/index.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getWebidFromTokenPayload = exports.fetchJwks = void 0;\nconst cross_fetch_1 = require(\"cross-fetch\");\nconst jose_1 = require(\"jose\");\nasync function fetchJwks(jwksIri, issuerIri) {\n    const jwksResponse = await (0, cross_fetch_1.fetch)(jwksIri);\n    if (jwksResponse.status !== 200) {\n        throw new Error(`Could not fetch JWKS for [${issuerIri}] at [${jwksIri}]: ${jwksResponse.status} ${jwksResponse.statusText}`);\n    }\n    let jwk;\n    try {\n        jwk = (await jwksResponse.json()).keys[0];\n    }\n    catch (e) {\n        throw new Error(`Malformed JWKS for [${issuerIri}] at [${jwksIri}]: ${e.message}`);\n    }\n    return jwk;\n}\nexports.fetchJwks = fetchJwks;\nasync function getWebidFromTokenPayload(idToken, jwksIri, issuerIri, clientId) {\n    const jwk = await fetchJwks(jwksIri, issuerIri);\n    let payload;\n    try {\n        const { payload: verifiedPayload } = await (0, jose_1.jwtVerify)(idToken, await (0, jose_1.importJWK)(jwk), {\n            issuer: issuerIri,\n            audience: clientId,\n        });\n        payload = verifiedPayload;\n    }\n    catch (e) {\n        throw new Error(`ID token verification failed: ${e.stack}`);\n    }\n    if (typeof payload.webid === \"string\") {\n        return payload.webid;\n    }\n    if (typeof payload.sub !== \"string\") {\n        throw new Error(`The ID token ${JSON.stringify(payload)} is invalid: it has no 'webid' claim and no 'sub' claim.`);\n    }\n    try {\n        new URL(payload.sub);\n        return payload.sub;\n    }\n    catch (e) {\n        throw new Error(`The ID token has no 'webid' claim, and its 'sub' claim of [${payload.sub}] is invalid as a URL - error [${e}].`);\n    }\n}\nexports.getWebidFromTokenPayload = getWebidFromTokenPayload;\n"},"sourceMaps":{"js":{"version":3,"file":"IRedirectHandler.js","sourceRoot":"","sources":["../../../../src/login/oidc/redirectHandler/IRedirectHandler.ts"],"names":[],"mappings":";;;AA2BA,6CAAoC;AACpC,+BAA6D;AAsBtD,KAAK,UAAU,SAAS,CAC7B,OAAe,EACf,SAAiB;IAMjB,MAAM,YAAY,GAAG,MAAM,IAAA,mBAAK,EAAC,OAAO,CAAC,CAAC;IAC1C,IAAI,YAAY,CAAC,MAAM,KAAK,GAAG,EAAE;QAC/B,MAAM,IAAI,KAAK,CACb,6BAA6B,SAAS,SAAS,OAAO,MAAM,YAAY,CAAC,MAAM,IAAI,YAAY,CAAC,UAAU,EAAE,CAC7G,CAAC;KACH;IAED,IAAI,GAAQ,CAAC;IACb,IAAI;QACF,GAAG,GAAG,CAAC,MAAM,YAAY,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAQ,CAAC;KAClD;IAAC,OAAO,CAAC,EAAE;QACV,MAAM,IAAI,KAAK,CACb,uBAAuB,SAAS,SAAS,OAAO,MAC7C,CAAiB,CAAC,OACrB,EAAE,CACH,CAAC;KACH;IACD,OAAO,GAAG,CAAC;AACb,CAAC;AA1BD,8BA0BC;AAWM,KAAK,UAAU,wBAAwB,CAC5C,OAAe,EACf,OAAe,EACf,SAAiB,EACjB,QAAgB;IAEhB,MAAM,GAAG,GAAG,MAAM,SAAS,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;IAChD,IAAI,OAAmB,CAAC;IACxB,IAAI;QACF,MAAM,EAAE,OAAO,EAAE,eAAe,EAAE,GAAG,MAAM,IAAA,gBAAS,EAClD,OAAO,EACP,MAAM,IAAA,gBAAS,EAAC,GAAG,CAAC,EACpB;YACE,MAAM,EAAE,SAAS;YACjB,QAAQ,EAAE,QAAQ;SACnB,CACF,CAAC;QACF,OAAO,GAAG,eAAe,CAAC;KAC3B;IAAC,OAAO,CAAC,EAAE;QACV,MAAM,IAAI,KAAK,CAAC,iCAAkC,CAAe,CAAC,KAAK,EAAE,CAAC,CAAC;KAC5E;IAED,IAAI,OAAO,OAAO,CAAC,KAAK,KAAK,QAAQ,EAAE;QACrC,OAAO,OAAO,CAAC,KAAK,CAAC;KACtB;IACD,IAAI,OAAO,OAAO,CAAC,GAAG,KAAK,QAAQ,EAAE;QACnC,MAAM,IAAI,KAAK,CACb,gBAAgB,IAAI,CAAC,SAAS,CAC5B,OAAO,CACR,0DAA0D,CAC5D,CAAC;KACH;IACD,IAAI;QAKF,IAAI,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QACrB,OAAO,OAAO,CAAC,GAAG,CAAC;KACpB;IAAC,OAAO,CAAC,EAAE;QACV,MAAM,IAAI,KAAK,CACb,8DAA8D,OAAO,CAAC,GAAG,kCAAkC,CAAC,IAAI,CACjH,CAAC;KACH;AACH,CAAC;AA5CD,4DA4CC","sourcesContent":["/*\n * Copyright 2022 Inrupt Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n * Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * @hidden\n * @packageDocumentation\n */\n\n// eslint-disable-next-line no-shadow\nimport { fetch } from \"cross-fetch\";\nimport { JWK, JWTPayload, jwtVerify, importJWK } from \"jose\";\nimport { EventEmitter } from \"events\";\nimport IHandleable from \"../../../util/handlerPattern/IHandleable\";\nimport { ISessionInfo } from \"../../../sessionInfo/ISessionInfo\";\n\nexport type RedirectResult = ISessionInfo & { fetch: typeof fetch };\nexport type RedirectInput = [string, EventEmitter | undefined];\n\n/**\n * @hidden\n */\ntype IRedirectHandler = IHandleable<\n  // Tuple of the URL to redirect to, an optional event listener for when\n  // we receive a new refresh token, and, an optional onError function:\n  RedirectInput,\n  RedirectResult\n>;\nexport default IRedirectHandler;\n\ntype WithMessage = { message: string };\ntype WithStack = { stack: string };\n\nexport async function fetchJwks(\n  jwksIri: string,\n  issuerIri: string\n): Promise<JWK> {\n  // FIXME: the following line works, but the underlying network calls don't seem\n  // to be mocked properly by our test code. It would be nicer to replace calls to this\n  // function by the following line and to fix the mocks.\n  // const jwks = createRemoteJWKSet(new URL(jwksIri));\n  const jwksResponse = await fetch(jwksIri);\n  if (jwksResponse.status !== 200) {\n    throw new Error(\n      `Could not fetch JWKS for [${issuerIri}] at [${jwksIri}]: ${jwksResponse.status} ${jwksResponse.statusText}`\n    );\n  }\n  // The JWKS should only contain the current key for the issuer.\n  let jwk: JWK;\n  try {\n    jwk = (await jwksResponse.json()).keys[0] as JWK;\n  } catch (e) {\n    throw new Error(\n      `Malformed JWKS for [${issuerIri}] at [${jwksIri}]: ${\n        (e as WithMessage).message\n      }`\n    );\n  }\n  return jwk;\n}\n\n/**\n * Extract a WebID from an ID token payload based on https://github.com/solid/webid-oidc-spec.\n * Note that this does not yet implement the user endpoint lookup, and only checks\n * for `webid` or IRI-like `sub` claims.\n *\n * @param idToken the payload of the ID token from which the WebID can be extracted.\n * @returns a WebID extracted from the ID token.\n * @internal\n */\nexport async function getWebidFromTokenPayload(\n  idToken: string,\n  jwksIri: string,\n  issuerIri: string,\n  clientId: string\n): Promise<string> {\n  const jwk = await fetchJwks(jwksIri, issuerIri);\n  let payload: JWTPayload;\n  try {\n    const { payload: verifiedPayload } = await jwtVerify(\n      idToken,\n      await importJWK(jwk),\n      {\n        issuer: issuerIri,\n        audience: clientId,\n      }\n    );\n    payload = verifiedPayload;\n  } catch (e) {\n    throw new Error(`ID token verification failed: ${(e as WithStack).stack}`);\n  }\n\n  if (typeof payload.webid === \"string\") {\n    return payload.webid;\n  }\n  if (typeof payload.sub !== \"string\") {\n    throw new Error(\n      `The ID token ${JSON.stringify(\n        payload\n      )} is invalid: it has no 'webid' claim and no 'sub' claim.`\n    );\n  }\n  try {\n    // This parses the 'sub' claim to check if it is a well-formed IRI.\n    // However, the normalized value isn't returned to make sure the WebID is returned\n    // as specified by the Identity Provider.\n    // eslint-disable-next-line no-new\n    new URL(payload.sub);\n    return payload.sub;\n  } catch (e) {\n    throw new Error(\n      `The ID token has no 'webid' claim, and its 'sub' claim of [${payload.sub}] is invalid as a URL - error [${e}].`\n    );\n  }\n}\n"]}},"error":null,"hash":"36544c506b31fe98b7307362fcfb46c0","cacheData":{"env":{}}}