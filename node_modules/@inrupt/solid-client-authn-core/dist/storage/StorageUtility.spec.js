"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const jose_1 = require("jose");
const globals_1 = require("@jest/globals");
const IssuerConfig_1 = require("../login/oidc/__mocks__/IssuerConfig");
const IssuerConfigFetcher_1 = require("../login/oidc/__mocks__/IssuerConfigFetcher");
const StorageUtility_1 = __importStar(require("./StorageUtility"));
const StorageUtility_2 = require("./__mocks__/StorageUtility");
(0, globals_1.describe)("StorageUtility", () => {
    const defaultMocks = {
        secureStorage: (0, StorageUtility_2.mockStorage)({}),
        insecureStorage: (0, StorageUtility_2.mockStorage)({}),
    };
    const key = "the key";
    const value = "the value";
    const userId = "animals";
    function getStorageUtility(mocks = defaultMocks) {
        var _a, _b;
        return new StorageUtility_1.default((_a = mocks.secureStorage) !== null && _a !== void 0 ? _a : defaultMocks.secureStorage, (_b = mocks.insecureStorage) !== null && _b !== void 0 ? _b : defaultMocks.insecureStorage);
    }
    (0, globals_1.describe)("get", () => {
        (0, globals_1.it)("gets an item from storage", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: (0, StorageUtility_2.mockStorage)({}),
            });
            await storageUtility.set(key, value);
            const result = await storageUtility.get(key);
            (0, globals_1.expect)(result).toBe(value);
        });
        (0, globals_1.it)("gets an item from (secure) storage", async () => {
            const storageUtility = getStorageUtility({
                secureStorage: (0, StorageUtility_2.mockStorage)({}),
            });
            await storageUtility.set(key, value, { secure: true });
            const result = await storageUtility.get(key, { secure: true });
            (0, globals_1.expect)(result).toBe(value);
        });
        (0, globals_1.it)("returns undefined if the item is not in storage", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: (0, StorageUtility_2.mockStorage)({}),
            });
            const retrievedValue = await storageUtility.get("key");
            (0, globals_1.expect)(retrievedValue).toBeUndefined();
        });
        (0, globals_1.it)("throws an error if the item is not in storage and errorOnNull is true", async () => {
            const storageMock = defaultMocks.insecureStorage;
            const storageUtility = getStorageUtility({
                insecureStorage: storageMock,
            });
            await (0, globals_1.expect)(storageUtility.get("key", { errorIfNull: true })).rejects.toThrow("[key] is not stored");
        });
    });
    (0, globals_1.describe)("set", () => {
        (0, globals_1.it)("sets an item in storage", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: (0, StorageUtility_2.mockStorage)({}),
            });
            await storageUtility.set(key, value);
            await (0, globals_1.expect)(storageUtility.get(key)).resolves.toEqual(value);
        });
    });
    (0, globals_1.describe)("delete", () => {
        (0, globals_1.it)("deletes an item", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: (0, StorageUtility_2.mockStorage)({}),
            });
            await (0, globals_1.expect)(storageUtility.get(key)).resolves.toBeUndefined();
            await storageUtility.set(key, value);
            await (0, globals_1.expect)(storageUtility.get(key)).resolves.toEqual(value);
            await storageUtility.delete(key);
            await (0, globals_1.expect)(storageUtility.get(key)).resolves.toBeUndefined();
        });
        (0, globals_1.it)("deletes an item (from secure storage)", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: (0, StorageUtility_2.mockStorage)({}),
            });
            await (0, globals_1.expect)(storageUtility.get(key, { secure: true })).resolves.toBeUndefined();
            await storageUtility.set(key, value, { secure: true });
            await (0, globals_1.expect)(storageUtility.get(key, { secure: true })).resolves.toEqual(value);
            await storageUtility.delete(key, { secure: true });
            await (0, globals_1.expect)(storageUtility.get(key, { secure: true })).resolves.toBeUndefined();
        });
    });
    (0, globals_1.describe)("getForUser", () => {
        (0, globals_1.it)("throws if data stored is invalid JSON", async () => {
            const mockedStorageUtility = (0, StorageUtility_2.mockStorage)({});
            mockedStorageUtility.get = globals_1.jest
                .fn()
                .mockReturnValue("This response deliberately cannot be parsed as JSON!");
            const storageUtility = getStorageUtility({
                insecureStorage: mockedStorageUtility,
                secureStorage: mockedStorageUtility,
            });
            await (0, globals_1.expect)(storageUtility.getForUser("irrelevant for this test", "Doesn't matter")).rejects.toThrow("cannot be parsed as JSON!");
            await (0, globals_1.expect)(storageUtility.getForUser("irrelevant for this test", "Doesn't matter", { secure: true })).rejects.toThrow("cannot be parsed as JSON!");
        });
        (0, globals_1.it)("gets an item from storage for a user", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: (0, StorageUtility_2.mockStorage)({}),
            });
            const userData = {
                jackie: "The Cat",
                sledge: "The Dog",
            };
            await storageUtility.setForUser(userId, userData);
            const retrievedValue = await storageUtility.getForUser(userId, "jackie");
            (0, globals_1.expect)(retrievedValue).toBe("The Cat");
        });
        (0, globals_1.it)("gets an item from (secure) storage for a user", async () => {
            const storageUtility = getStorageUtility({
                secureStorage: (0, StorageUtility_2.mockStorage)({}),
            });
            const userData = {
                jackie: "The Cat",
                sledge: "The Dog",
            };
            await storageUtility.setForUser(userId, userData, {
                secure: true,
            });
            const retrievedValue = await storageUtility.getForUser(userId, "jackie", {
                secure: true,
            });
            (0, globals_1.expect)(retrievedValue).toBe("The Cat");
        });
        (0, globals_1.it)("returns undefined if no item is in storage", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: (0, StorageUtility_2.mockStorage)({}),
            });
            const retrievedValue = await storageUtility.getForUser(userId, "jackie");
            (0, globals_1.expect)(retrievedValue).toBeUndefined();
        });
        (0, globals_1.it)("returns null if the item in storage is corrupted", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: (0, StorageUtility_2.mockStorage)({}),
            });
            await storageUtility.setForUser(userId, {
                cool: "bleep bloop not parsable",
            });
            const retrievedValue = await storageUtility.getForUser(userId, "jackie");
            (0, globals_1.expect)(retrievedValue).toBeUndefined();
        });
        (0, globals_1.it)("throws an error if the item is not in storage and errorOnNull is true", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: (0, StorageUtility_2.mockStorage)({}),
            });
            await (0, globals_1.expect)(storageUtility.getForUser(userId, "jackie", { errorIfNull: true })).rejects.toThrow(`Field [jackie] for user [${userId}] is not stored`);
        });
    });
    (0, globals_1.describe)("setForUser", () => {
        (0, globals_1.it)("sets a value for a user", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: (0, StorageUtility_2.mockStorage)({}),
            });
            await storageUtility.setForUser(userId, {
                jackie: "The Pretty Kitty",
            });
            const retrievedValue = await storageUtility.getForUser(userId, "jackie");
            (0, globals_1.expect)(retrievedValue).toBe("The Pretty Kitty");
        });
        (0, globals_1.it)("sets a value for a user if the original data was corrupted", async () => {
            const storageMock = defaultMocks.insecureStorage;
            await storageMock.set(`solidClientAuthenticationUser:${userId}`, 'cool: "bleep bloop not parsable"');
            const storageUtility = getStorageUtility({
                insecureStorage: storageMock,
            });
            await storageUtility.setForUser(userId, {
                jackie: "The Pretty Kitty",
            });
            const retrievedValue = await storageUtility.getForUser(userId, "jackie");
            (0, globals_1.expect)(retrievedValue).toBe("The Pretty Kitty");
        });
    });
    (0, globals_1.describe)("deleteForUser", () => {
        (0, globals_1.it)("deletes a value for a user from unsecure storage", async () => {
            const userData = {
                jackie: "The Cat",
                sledge: "The Dog",
            };
            const storageUtility = getStorageUtility({
                insecureStorage: (0, StorageUtility_2.mockStorage)({}),
            });
            await storageUtility.setForUser(userId, userData);
            await storageUtility.deleteForUser(userId, "jackie");
            await (0, globals_1.expect)(storageUtility.getForUser(userId, "jackie")).resolves.toBeUndefined();
            await (0, globals_1.expect)(storageUtility.getForUser(userId, "sledge")).resolves.toBe("The Dog");
        });
        (0, globals_1.it)("deletes a value for a user from secure storage", async () => {
            const storageUtility = getStorageUtility({
                secureStorage: (0, StorageUtility_2.mockStorage)({
                    "solidClientAuthenticationUser:someUser": {
                        jackie: "The Cat",
                        sledge: "The Dog",
                    },
                }),
            });
            await storageUtility.deleteForUser("someUser", "jackie", {
                secure: true,
            });
            await (0, globals_1.expect)(storageUtility.getForUser("someUser", "jackie", { secure: true })).resolves.toBeUndefined();
            await (0, globals_1.expect)(storageUtility.getForUser("someUser", "sledge", { secure: true })).resolves.toBe("The Dog");
        });
    });
    (0, globals_1.describe)("deleteAllUserData", () => {
        (0, globals_1.it)("deletes all data for a particular user", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: (0, StorageUtility_2.mockStorage)({}),
            });
            const userData = {
                jackie: "The Cat",
                sledge: "The Dog",
            };
            await storageUtility.setForUser(userId, userData);
            await (0, globals_1.expect)(storageUtility.getForUser(userId, "jackie")).resolves.toBe("The Cat");
            await storageUtility.deleteAllUserData(userId);
            await (0, globals_1.expect)(storageUtility.getForUser(userId, "jackie")).resolves.toBeUndefined();
        });
        (0, globals_1.it)("deletes all data for a particular user (from secure storage)", async () => {
            const storageUtility = getStorageUtility({
                secureStorage: (0, StorageUtility_2.mockStorage)({}),
            });
            const userData = {
                jackie: "The Cat",
                sledge: "The Dog",
            };
            await storageUtility.setForUser(userId, userData, { secure: true });
            await (0, globals_1.expect)(storageUtility.getForUser(userId, "jackie", { secure: true })).resolves.toBe("The Cat");
            await storageUtility.deleteAllUserData(userId, { secure: true });
            await (0, globals_1.expect)(storageUtility.getForUser(userId, "jackie", { secure: true })).resolves.toBeUndefined();
        });
    });
    (0, globals_1.describe)("storeResourceServerSessionInfo", () => {
        (0, globals_1.it)("stores session information for a new WebID", async () => {
            var _a;
            const storageUtility = getStorageUtility({
                insecureStorage: (0, StorageUtility_2.mockStorage)({}),
            });
            await storageUtility.storeResourceServerSessionInfo("https://some.pod/profile#me", "https://some-resource.provider/", 1610026667);
            (0, globals_1.expect)(JSON.parse((_a = (await storageUtility.get("tmp-resource-server-session-info"))) !== null && _a !== void 0 ? _a : "{}")).toEqual({
                webId: "https://some.pod/profile#me",
                sessions: {
                    "https://some-resource.provider/": {
                        expiration: 1610026667,
                    },
                },
            });
        });
        (0, globals_1.it)("adds a new resource server to a WebID that is already registered", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: (0, StorageUtility_2.mockStorage)({
                    "tmp-resource-server-session-info": JSON.stringify({
                        webId: "https://some.pod/profile#me",
                        sessions: {
                            "https://some-other-resource.provider/": {
                                expiration: 1610026667,
                            },
                        },
                    }),
                }),
            });
            await storageUtility.storeResourceServerSessionInfo("https://some.pod/profile#me", "https://some-resource.provider/", 1610026667);
            await (0, globals_1.expect)(storageUtility.get("tmp-resource-server-session-info")).resolves.toEqual(JSON.stringify({
                webId: "https://some.pod/profile#me",
                sessions: {
                    "https://some-other-resource.provider/": {
                        expiration: 1610026667,
                    },
                    "https://some-resource.provider/": {
                        expiration: 1610026667,
                    },
                },
            }));
        });
        (0, globals_1.it)("overwrites existing sessions when storing a session for a new WebID", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: (0, StorageUtility_2.mockStorage)({
                    "tmp-resource-server-session-info": JSON.stringify({
                        webId: "https://some-other.pod/profile#me",
                        sessions: {
                            "https://some-other-resource.provider/": {
                                expiration: 1610026667,
                            },
                        },
                    }),
                }),
            });
            await storageUtility.storeResourceServerSessionInfo("https://some.pod/profile#me", "https://some-resource.provider/", 1610026667);
            await (0, globals_1.expect)(storageUtility.get("tmp-resource-server-session-info")).resolves.toEqual(JSON.stringify({
                webId: "https://some.pod/profile#me",
                sessions: {
                    "https://some-resource.provider/": {
                        expiration: 1610026667,
                    },
                },
            }));
        });
    });
    (0, globals_1.describe)("clearResourceServerSessionInfo", () => {
        (0, globals_1.it)("doesn't not fail if the WebID does not exist", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: (0, StorageUtility_2.mockStorage)({}),
            });
            await storageUtility.clearResourceServerSessionInfo("https://some-resource.provider/");
            await (0, globals_1.expect)(storageUtility.get("tmp-resource-server-session-info")).resolves.toBeUndefined();
        });
        (0, globals_1.it)("clears the session info object if no session is active", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: (0, StorageUtility_2.mockStorage)({
                    "tmp-resource-server-session-info": JSON.stringify({
                        webId: "https://some.pod/profile#me",
                        sessions: {
                            "https://some-resource.provider/": {
                                expiration: 1610026667,
                            },
                        },
                    }),
                }),
            });
            await storageUtility.clearResourceServerSessionInfo("https://some-resource.provider/");
            await (0, globals_1.expect)(storageUtility.get("tmp-resource-server-session-info")).resolves.toEqual(JSON.stringify({}));
        });
        (0, globals_1.it)("removes the given resource server session info", async () => {
            const storageUtility = getStorageUtility({
                insecureStorage: (0, StorageUtility_2.mockStorage)({
                    "tmp-resource-server-session-info": JSON.stringify({
                        webId: "https://some.pod/profile#me",
                        sessions: {
                            "https://some-resource.provider/": {
                                expiration: 1610026667,
                            },
                        },
                    }),
                }),
            });
            await storageUtility.clearResourceServerSessionInfo("https://some-other-resource.provider/");
            await (0, globals_1.expect)(storageUtility.get("tmp-resource-server-session-info")).resolves.toEqual(JSON.stringify({
                webId: "https://some.pod/profile#me",
                sessions: {
                    "https://some-resource.provider/": {
                        expiration: 1610026667,
                    },
                },
            }));
        });
    });
});
(0, globals_1.describe)("getSessionIdFromOauthState", () => {
    (0, globals_1.it)("returns stored OIDC 'state' for request's OIDC 'state' value", async () => {
        const oauthState = "some existent 'state'";
        const oauthStateValue = "some existent 'state' value";
        const mockedStorage = (0, StorageUtility_2.mockStorageUtility)({
            [`solidClientAuthenticationUser:${oauthState}`]: {
                sessionId: oauthStateValue,
            },
        }, false);
        await (0, globals_1.expect)((0, StorageUtility_1.getSessionIdFromOauthState)(mockedStorage, oauthState)).resolves.toBe(oauthStateValue);
    });
    (0, globals_1.it)("returns undefined if no stored OIDC 'state' matches the current request's OIDC 'state' value", async () => {
        const mockedStorage = (0, StorageUtility_2.mockStorageUtility)({});
        await (0, globals_1.expect)((0, StorageUtility_1.getSessionIdFromOauthState)(mockedStorage, "some non-existent 'state' value")).resolves.toBeUndefined();
    });
});
(0, globals_1.describe)("loadOidcContextFromStorage", () => {
    (0, globals_1.it)("throws if no issuer is stored for the user", async () => {
        const mockedStorage = (0, StorageUtility_2.mockStorageUtility)({
            "solidClientAuthenticationUser:mySession": {
                codeVerifier: "some code verifier",
                redirectUrl: "https://my.app/redirect",
                dpop: "true",
            },
        });
        await (0, globals_1.expect)((0, StorageUtility_1.loadOidcContextFromStorage)("mySession", mockedStorage, (0, IssuerConfigFetcher_1.mockIssuerConfigFetcher)((0, IssuerConfig_1.mockIssuerConfig)()))).rejects.toThrow("Failed to retrieve OIDC context from storage associated with session [mySession]");
    });
    (0, globals_1.it)("throws if no token type is stored for the user", async () => {
        const mockedStorage = (0, StorageUtility_2.mockStorageUtility)({
            "solidClientAuthenticationUser:mySession": {
                issuer: "https://my.idp/",
                codeVerifier: "some code verifier",
                redirectUrl: "https://my.app/redirect",
            },
        });
        await (0, globals_1.expect)((0, StorageUtility_1.loadOidcContextFromStorage)("mySession", mockedStorage, (0, IssuerConfigFetcher_1.mockIssuerConfigFetcher)((0, IssuerConfig_1.mockIssuerConfig)()))).rejects.toThrow("Failed to retrieve OIDC context from storage associated with session [mySession]");
    });
    (0, globals_1.it)("Returns the value in storage if available", async () => {
        const mockedStorage = (0, StorageUtility_2.mockStorageUtility)({
            "solidClientAuthenticationUser:mySession": {
                issuer: "https://my.idp/",
                codeVerifier: "some code verifier",
                redirectUrl: "https://my.app/redirect",
                dpop: "true",
            },
        });
        await (0, globals_1.expect)((0, StorageUtility_1.loadOidcContextFromStorage)("mySession", mockedStorage, (0, IssuerConfigFetcher_1.mockIssuerConfigFetcher)((0, IssuerConfig_1.mockIssuerConfig)()))).resolves.toEqual({
            issuerConfig: (0, IssuerConfig_1.mockIssuerConfig)(),
            codeVerifier: "some code verifier",
            redirectUrl: "https://my.app/redirect",
            dpop: true,
        });
    });
    (0, globals_1.it)("Clears the code verifier", async () => {
        const mockedStorage = (0, StorageUtility_2.mockStorageUtility)({
            "solidClientAuthenticationUser:mySession": {
                issuer: "https://my.idp/",
                codeVerifier: "some code verifier",
                redirectUrl: "https://my.app/redirect",
                dpop: "true",
            },
        });
        await (0, StorageUtility_1.loadOidcContextFromStorage)("mySession", mockedStorage, (0, IssuerConfigFetcher_1.mockIssuerConfigFetcher)((0, IssuerConfig_1.mockIssuerConfig)()));
        await (0, globals_1.expect)(mockedStorage.getForUser("mySession", "codeVerifier")).resolves.toBeUndefined();
    });
});
(0, globals_1.describe)("saveSessionInfoToStorage", () => {
    (0, globals_1.it)("saves the refresh token if provided in the given storage", async () => {
        const mockedStorage = (0, StorageUtility_2.mockStorageUtility)({});
        await (0, StorageUtility_1.saveSessionInfoToStorage)(mockedStorage, "some session", "https://my.webid", "true", "a refresh token", true);
        await (0, globals_1.expect)(mockedStorage.getForUser("some session", "refreshToken", { secure: true })).resolves.toBe("a refresh token");
    });
    (0, globals_1.it)("saves the webid if provided in the given storage", async () => {
        const mockedStorage = (0, StorageUtility_2.mockStorageUtility)({});
        await (0, StorageUtility_1.saveSessionInfoToStorage)(mockedStorage, "some session", "https://my.webid", undefined, undefined, true);
        await (0, globals_1.expect)(mockedStorage.getForUser("some session", "webId", { secure: true })).resolves.toBe("https://my.webid");
    });
    (0, globals_1.it)("saves the logged in status if provided in the given storage", async () => {
        const mockedStorage = (0, StorageUtility_2.mockStorageUtility)({});
        await (0, StorageUtility_1.saveSessionInfoToStorage)(mockedStorage, "some session", undefined, "true", undefined, true);
        await (0, globals_1.expect)(mockedStorage.getForUser("some session", "isLoggedIn", { secure: true })).resolves.toBe("true");
    });
    let publicKey;
    let privateKey;
    const mockJwk = async () => {
        if (typeof publicKey === "undefined" || typeof privateKey === "undefined") {
            const generatedPair = await (0, jose_1.generateKeyPair)("ES256");
            publicKey = generatedPair.publicKey;
            privateKey = generatedPair.privateKey;
        }
        return {
            publicKey,
            privateKey,
        };
    };
    const mockKeyPair = async () => {
        const { privateKey: prvt, publicKey: pblc } = await mockJwk();
        const dpopKeyPair = {
            privateKey: prvt,
            publicKey: await (0, jose_1.exportJWK)(pblc),
        };
        dpopKeyPair.publicKey.alg = "ES256";
        return dpopKeyPair;
    };
    (0, globals_1.it)("saves the DPoP key if provided in the given storage", async () => {
        const mockedStorage = (0, StorageUtility_2.mockStorageUtility)({});
        const dpopKey = await mockKeyPair();
        await (0, StorageUtility_1.saveSessionInfoToStorage)(mockedStorage, "some session", "https://my.webid", "true", "a refresh token", true, dpopKey);
        (0, globals_1.expect)(JSON.parse((await mockedStorage.getForUser("some session", "publicKey", {
            secure: true,
        })))).toEqual(dpopKey.publicKey);
        const privateJwk = await mockedStorage.getForUser("some session", "privateKey", { secure: true });
        (0, globals_1.expect)(JSON.parse(privateJwk)).toEqual(await (0, jose_1.exportJWK)(dpopKey.privateKey));
    });
});
//# sourceMappingURL=StorageUtility.spec.js.map