{"id":"node_modules/@inrupt/solid-client-authn-browser/dist/Session.js","dependencies":[{"name":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-browser/dist/Session.js.map","includedInParent":true,"mtime":1652099631558},{"name":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-browser/src/Session.ts","includedInParent":true,"mtime":1652099631832},{"name":"/Users/tdrave/demo-solid-app/package.json","includedInParent":true,"mtime":1652099771977},{"name":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-browser/package.json","includedInParent":true,"mtime":1652099631546},{"name":"events","loc":{"line":4,"column":25,"index":159},"parent":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-browser/dist/Session.js","resolved":"/Users/tdrave/demo-solid-app/node_modules/events/events.js"},{"name":"@inrupt/solid-client-authn-core","loc":{"line":5,"column":42,"index":212},"parent":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-browser/dist/Session.js","resolved":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-core/dist/index.js"},{"name":"uuid","loc":{"line":6,"column":23,"index":271},"parent":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-browser/dist/Session.js","resolved":"/Users/tdrave/demo-solid-app/node_modules/uuid/dist/esm-browser/index.js"},{"name":"./dependencies","loc":{"line":7,"column":31,"index":311},"parent":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-browser/dist/Session.js","resolved":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-browser/dist/dependencies.js"},{"name":"./constant","loc":{"line":8,"column":27,"index":357},"parent":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-browser/dist/Session.js","resolved":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-browser/dist/constant.js"},{"name":"./iframe","loc":{"line":9,"column":25,"index":397},"parent":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-browser/dist/Session.js","resolved":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-browser/dist/iframe.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Session = exports.silentlyAuthenticate = void 0;\nconst events_1 = require(\"events\");\nconst solid_client_authn_core_1 = require(\"@inrupt/solid-client-authn-core\");\nconst uuid_1 = require(\"uuid\");\nconst dependencies_1 = require(\"./dependencies\");\nconst constant_1 = require(\"./constant\");\nconst iframe_1 = require(\"./iframe\");\nasync function silentlyAuthenticate(sessionId, clientAuthn, options = {\n    inIframe: false,\n}, session) {\n    var _a;\n    const storedSessionInfo = await clientAuthn.validateCurrentSession(sessionId);\n    if (storedSessionInfo !== null) {\n        window.localStorage.setItem(constant_1.KEY_CURRENT_URL, window.location.href);\n        await clientAuthn.login({\n            sessionId,\n            prompt: \"none\",\n            oidcIssuer: storedSessionInfo.issuer,\n            redirectUrl: storedSessionInfo.redirectUrl,\n            clientId: storedSessionInfo.clientAppId,\n            clientSecret: storedSessionInfo.clientAppSecret,\n            tokenType: (_a = storedSessionInfo.tokenType) !== null && _a !== void 0 ? _a : \"DPoP\",\n            inIframe: options.inIframe,\n        }, session);\n        return true;\n    }\n    return false;\n}\nexports.silentlyAuthenticate = silentlyAuthenticate;\nfunction isLoggedIn(sessionInfo) {\n    return !!(sessionInfo === null || sessionInfo === void 0 ? void 0 : sessionInfo.isLoggedIn);\n}\nclass Session extends events_1.EventEmitter {\n    constructor(sessionOptions = {}, sessionId) {\n        super();\n        this.tokenRequestInProgress = false;\n        this.tmpFetchWithCookies = false;\n        this.login = async (options) => {\n            var _a;\n            await this.clientAuthentication.login({\n                sessionId: this.info.sessionId,\n                ...options,\n                tokenType: (_a = options.tokenType) !== null && _a !== void 0 ? _a : \"DPoP\",\n            }, this);\n            return new Promise(() => undefined);\n        };\n        this.fetch = async (url, init) => {\n            return this.clientAuthentication.fetch(url, {\n                ...init,\n                credentials: this.tmpFetchWithCookies\n                    ?\n                        \"include\"\n                    :\n                        init === null || init === void 0 ? void 0 : init.credentials,\n            });\n        };\n        this.internalLogout = async (emitSignal) => {\n            window.localStorage.removeItem(constant_1.KEY_CURRENT_SESSION);\n            await this.clientAuthentication.logout(this.info.sessionId);\n            this.info.isLoggedIn = false;\n            this.tmpFetchWithCookies = false;\n            if (emitSignal) {\n                this.emit(solid_client_authn_core_1.EVENTS.LOGOUT);\n            }\n        };\n        this.logout = async () => this.internalLogout(true);\n        this.handleIncomingRedirect = async (inputOptions = {}) => {\n            var _a;\n            if (this.info.isLoggedIn) {\n                return this.info;\n            }\n            if (this.tokenRequestInProgress) {\n                return undefined;\n            }\n            const options = typeof inputOptions === \"string\" ? { url: inputOptions } : inputOptions;\n            const url = (_a = options.url) !== null && _a !== void 0 ? _a : window.location.href;\n            if (window.frameElement !== null) {\n                (0, iframe_1.postRedirectUrlToParent)(url);\n                return undefined;\n            }\n            if (options.useEssSession !== true ||\n                options.restorePreviousSession === true) {\n                window.localStorage.setItem(\"tmp-resource-server-session-enabled\", \"false\");\n            }\n            else {\n                window.localStorage.setItem(\"tmp-resource-server-session-enabled\", \"true\");\n            }\n            const storedSessionCookieReference = window.localStorage.getItem(\"tmp-resource-server-session-info\");\n            if (typeof storedSessionCookieReference === \"string\" &&\n                options.restorePreviousSession !== true &&\n                options.useEssSession === true) {\n                function isValidSessionCookieReference(reference) {\n                    var _a;\n                    const resourceServers = Object.keys((_a = reference.sessions) !== null && _a !== void 0 ? _a : {});\n                    return (typeof reference.webId === \"string\" &&\n                        resourceServers.length > 0 &&\n                        typeof reference.sessions[resourceServers[0]].expiration === \"number\");\n                }\n                const reference = JSON.parse(storedSessionCookieReference);\n                if (isValidSessionCookieReference(reference)) {\n                    const resourceServers = Object.keys(reference.sessions);\n                    const webIdOrigin = new URL(reference.webId).hostname;\n                    const ownResourceServer = resourceServers.find((resourceServer) => {\n                        return new URL(resourceServer).hostname === webIdOrigin;\n                    });\n                    const relevantServer = ownResourceServer !== null && ownResourceServer !== void 0 ? ownResourceServer : resourceServers[0];\n                    if (reference.sessions[relevantServer].expiration - Date.now() >\n                        5 * 60 * 1000) {\n                        this.info.isLoggedIn = true;\n                        this.info.webId = reference.webId;\n                        this.tmpFetchWithCookies = true;\n                        return this.info;\n                    }\n                }\n            }\n            this.tokenRequestInProgress = true;\n            const sessionInfo = await this.clientAuthentication.handleIncomingRedirect(url, this);\n            if (isLoggedIn(sessionInfo)) {\n                this.setSessionInfo(sessionInfo);\n                const currentUrl = window.localStorage.getItem(constant_1.KEY_CURRENT_URL);\n                if (currentUrl === null) {\n                    this.emit(solid_client_authn_core_1.EVENTS.LOGIN);\n                }\n                else {\n                    window.localStorage.removeItem(constant_1.KEY_CURRENT_URL);\n                    this.emit(solid_client_authn_core_1.EVENTS.SESSION_RESTORED, currentUrl);\n                }\n            }\n            else if (options.restorePreviousSession === true) {\n                const storedSessionId = window.localStorage.getItem(constant_1.KEY_CURRENT_SESSION);\n                if (storedSessionId !== null) {\n                    const attemptedSilentAuthentication = await silentlyAuthenticate(storedSessionId, this.clientAuthentication, undefined, this);\n                    if (attemptedSilentAuthentication) {\n                        return new Promise(() => { });\n                    }\n                }\n            }\n            this.tokenRequestInProgress = false;\n            return sessionInfo;\n        };\n        if (sessionOptions.clientAuthentication) {\n            this.clientAuthentication = sessionOptions.clientAuthentication;\n        }\n        else if (sessionOptions.secureStorage && sessionOptions.insecureStorage) {\n            this.clientAuthentication = (0, dependencies_1.getClientAuthenticationWithDependencies)({\n                secureStorage: sessionOptions.secureStorage,\n                insecureStorage: sessionOptions.insecureStorage,\n            });\n        }\n        else {\n            this.clientAuthentication = (0, dependencies_1.getClientAuthenticationWithDependencies)({});\n        }\n        if (sessionOptions.sessionInfo) {\n            this.info = {\n                sessionId: sessionOptions.sessionInfo.sessionId,\n                isLoggedIn: false,\n                webId: sessionOptions.sessionInfo.webId,\n            };\n        }\n        else {\n            this.info = {\n                sessionId: sessionId !== null && sessionId !== void 0 ? sessionId : (0, uuid_1.v4)(),\n                isLoggedIn: false,\n            };\n        }\n        (0, iframe_1.setupIframeListener)(async (redirectUrl) => {\n            const sessionInfo = await this.clientAuthentication.handleIncomingRedirect(redirectUrl, this);\n            if (!isLoggedIn(sessionInfo)) {\n                return;\n            }\n            this.setSessionInfo(sessionInfo);\n        });\n        this.on(\"tokenRenewal\", () => silentlyAuthenticate(this.info.sessionId, this.clientAuthentication, {\n            inIframe: true,\n        }, this));\n        this.on(solid_client_authn_core_1.EVENTS.LOGIN, () => window.localStorage.setItem(constant_1.KEY_CURRENT_SESSION, this.info.sessionId));\n        this.on(solid_client_authn_core_1.EVENTS.SESSION_EXPIRED, () => this.internalLogout(false));\n        this.on(solid_client_authn_core_1.EVENTS.ERROR, () => this.internalLogout(false));\n    }\n    onLogin(callback) {\n        this.on(solid_client_authn_core_1.EVENTS.LOGIN, callback);\n    }\n    onLogout(callback) {\n        this.on(solid_client_authn_core_1.EVENTS.LOGOUT, callback);\n    }\n    onError(callback) {\n        this.on(solid_client_authn_core_1.EVENTS.ERROR, callback);\n    }\n    onSessionRestore(callback) {\n        this.on(solid_client_authn_core_1.EVENTS.SESSION_RESTORED, callback);\n    }\n    onSessionExpiration(callback) {\n        this.on(solid_client_authn_core_1.EVENTS.SESSION_EXPIRED, callback);\n    }\n    setSessionInfo(sessionInfo) {\n        this.info.isLoggedIn = sessionInfo.isLoggedIn;\n        this.info.webId = sessionInfo.webId;\n        this.info.sessionId = sessionInfo.sessionId;\n        this.info.expirationDate = sessionInfo.expirationDate;\n        this.on(solid_client_authn_core_1.EVENTS.SESSION_EXTENDED, (expiresIn) => {\n            this.info.expirationDate = Date.now() + expiresIn * 1000;\n        });\n    }\n}\nexports.Session = Session;\n"},"sourceMaps":{"js":{"version":3,"file":"Session.js","sourceRoot":"","sources":["../src/Session.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2022 Inrupt Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n * Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * @hidden\n */\nimport { EventEmitter } from \"events\";\nimport {\n  EVENTS,\n  ILoginInputOptions,\n  ISessionInfo,\n  IStorage,\n  ResourceServerSession,\n} from \"@inrupt/solid-client-authn-core\";\nimport { v4 } from \"uuid\";\nimport ClientAuthentication from \"./ClientAuthentication\";\nimport { getClientAuthenticationWithDependencies } from \"./dependencies\";\nimport { KEY_CURRENT_SESSION, KEY_CURRENT_URL } from \"./constant\";\nimport { postRedirectUrlToParent, setupIframeListener } from \"./iframe\";\n\nexport interface ISessionOptions {\n  /**\n   * A private storage, unreachable to other scripts on the page. Typically in-memory.\n   */\n  secureStorage: IStorage;\n  /**\n   * A storage where non-sensitive information may be stored, potentially longer-lived than the secure storage.\n   */\n  insecureStorage: IStorage;\n  /**\n   * Details about the current session\n   */\n  sessionInfo: ISessionInfo;\n  /**\n   * An instance of the library core. Typically obtained using `getClientAuthenticationWithDependencies`.\n   */\n  clientAuthentication: ClientAuthentication;\n}\n\nexport interface IHandleIncomingRedirectOptions {\n  /**\n   * If the user has signed in before, setting this to `true` will automatically\n   * redirect them to their Solid Identity Provider, which will then attempt to\n   * re-activate the session and send the user back to your app without\n   * requiring user interaction.\n   * If your app's access has not expired yet and re-activation completed\n   * successfully, a `sessionRestore` event will be fired with the URL the user\n   * was at before they were redirected to their Solid Identity Provider.\n   * {@see onSessionRestore}\n   */\n  restorePreviousSession?: boolean;\n\n  /**\n   * Inrupt's Enterprise Solid Server can set a cookie to allow the browser to\n   * access private resources on a Pod. In order to mitigate the logout-on-refresh\n   * issue on the short term, the server also implemented a session endpoint\n   * enabling the client app to know whether the cookie is set. When a user\n   * logs in to a server that has that capability enabled, applications that set\n   * this option to `true` will be able to make use of it.\n   *\n   * If your app supports the newest session restore approach, and `restorePreviousSession`\n   * is set to true, this option is automatically set to false, but your app will\n   * not be logged out when reloaded.\n   *\n   * `useEssSession` defaults to false and will be removed in the future; to\n   * preserve sessions across page reloads, use of `restorePreviousSession` is\n   * recommended.\n   */\n  useEssSession?: boolean;\n  /**\n   * The URL of the page handling the redirect, including the query\n   * parameters — these contain the information to process the login.\n   * Note: as a convenience, if no URL value is specified here, we default to\n   * using the browser's current location.\n   */\n  url?: string;\n}\n\nexport async function silentlyAuthenticate(\n  sessionId: string,\n  clientAuthn: ClientAuthentication,\n  options: {\n    inIframe?: boolean;\n  } = {\n    inIframe: false,\n  },\n  session: Session\n): Promise<boolean> {\n  const storedSessionInfo = await clientAuthn.validateCurrentSession(sessionId);\n  if (storedSessionInfo !== null) {\n    // It can be really useful to save the user's current browser location,\n    // so that we can restore it after completing the silent authentication\n    // on incoming redirect. This way, the user is eventually redirected back\n    // to the page they were on and not to the app's redirect page.\n    window.localStorage.setItem(KEY_CURRENT_URL, window.location.href);\n    await clientAuthn.login(\n      {\n        sessionId,\n        prompt: \"none\",\n        oidcIssuer: storedSessionInfo.issuer,\n        redirectUrl: storedSessionInfo.redirectUrl,\n        clientId: storedSessionInfo.clientAppId,\n        clientSecret: storedSessionInfo.clientAppSecret,\n        tokenType: storedSessionInfo.tokenType ?? \"DPoP\",\n        inIframe: options.inIframe,\n      },\n      session\n    );\n    return true;\n  }\n  return false;\n}\n\nfunction isLoggedIn(\n  sessionInfo?: ISessionInfo\n): sessionInfo is ISessionInfo & { isLoggedIn: true } {\n  return !!sessionInfo?.isLoggedIn;\n}\n\n/**\n * A {@link Session} object represents a user's session on an application. The session holds state, as it stores information enabling acces to private resources after login for instance.\n */\nexport class Session extends EventEmitter {\n  /**\n   * Information regarding the current session.\n   */\n  public readonly info: ISessionInfo;\n\n  private clientAuthentication: ClientAuthentication;\n\n  private tokenRequestInProgress = false;\n\n  // Remove this when removing the `useEssSession` workaround:\n  private tmpFetchWithCookies = false;\n\n  /**\n   * Session object constructor. Typically called as follows:\n   *\n   * ```typescript\n   * const session = new Session();\n   * ```\n   *\n   * See also [getDefaultSession](https://docs.inrupt.com/developer-tools/api/javascript/solid-client-authn-browser/functions.html#getdefaultsession).\n   *\n   * @param sessionOptions The options enabling the correct instantiation of\n   * the session. Either both storages or clientAuthentication are required. For\n   * more information, see {@link ISessionOptions}.\n   * @param sessionId A string uniquely identifying the session.\n   *\n   */\n  constructor(\n    sessionOptions: Partial<ISessionOptions> = {},\n    sessionId?: string\n  ) {\n    super();\n\n    if (sessionOptions.clientAuthentication) {\n      this.clientAuthentication = sessionOptions.clientAuthentication;\n    } else if (sessionOptions.secureStorage && sessionOptions.insecureStorage) {\n      this.clientAuthentication = getClientAuthenticationWithDependencies({\n        secureStorage: sessionOptions.secureStorage,\n        insecureStorage: sessionOptions.insecureStorage,\n      });\n    } else {\n      this.clientAuthentication = getClientAuthenticationWithDependencies({});\n    }\n\n    if (sessionOptions.sessionInfo) {\n      this.info = {\n        sessionId: sessionOptions.sessionInfo.sessionId,\n        isLoggedIn: false,\n        webId: sessionOptions.sessionInfo.webId,\n      };\n    } else {\n      this.info = {\n        sessionId: sessionId ?? v4(),\n        isLoggedIn: false,\n      };\n    }\n\n    // Listen for messages from children iframes.\n    setupIframeListener(async (redirectUrl: string) => {\n      const sessionInfo =\n        await this.clientAuthentication.handleIncomingRedirect(\n          redirectUrl,\n          this\n        );\n\n      // If silent authentication was not successful, do nothing;\n      // the existing session might still be valid for a while,\n      // and will expire by itself.\n      if (!isLoggedIn(sessionInfo)) {\n        return;\n      }\n      // After having revalidated the session,\n      // make sure to apply the new expiration time:\n      this.setSessionInfo(sessionInfo);\n    });\n    // Listen for the 'tokenRenewal' signal to trigger the silent token renewal.\n    this.on(\"tokenRenewal\", () =>\n      silentlyAuthenticate(\n        this.info.sessionId,\n        this.clientAuthentication,\n        {\n          inIframe: true,\n        },\n        this\n      )\n    );\n\n    // When a session is logged in, we want to track its ID in local storage to\n    // enable silent refresh. The current session ID specifically stored in 'localStorage'\n    // (as opposed to using our storage abstraction layer) because it is only\n    // used in a browser-specific mechanism.\n    this.on(EVENTS.LOGIN, () =>\n      window.localStorage.setItem(KEY_CURRENT_SESSION, this.info.sessionId)\n    );\n\n    this.on(EVENTS.SESSION_EXPIRED, () => this.internalLogout(false));\n\n    this.on(EVENTS.ERROR, () => this.internalLogout(false));\n  }\n\n  /**\n   * Triggers the login process. Note that this method will redirect the user away from your app.\n   *\n   * @param options Parameter to customize the login behaviour. In particular, two options are mandatory: `options.oidcIssuer`, the user's identity provider, and `options.redirectUrl`, the URL to which the user will be redirected after logging in their identity provider.\n   * @returns This method should redirect the user away from the app: it does not return anything. The login process is completed by {@linkcode handleIncomingRedirect}.\n   */\n  // Define these functions as properties so that they don't get accidentally re-bound.\n  // Isn't Javascript fun?\n  login = async (options: ILoginInputOptions): Promise<void> => {\n    await this.clientAuthentication.login(\n      {\n        sessionId: this.info.sessionId,\n        ...options,\n        // Defaults the token type to DPoP\n        tokenType: options.tokenType ?? \"DPoP\",\n      },\n      this\n    );\n    // `login` redirects the user away from the app,\n    // so unless it throws an error, there is no code that should run afterwards\n    // (since there is no \"after\" in the lifetime of the script).\n    // Hence, this Promise never resolves:\n    return new Promise(() => undefined);\n  };\n\n  /**\n   * Fetches data using available login information. If the user is not logged in, this will behave as a regular `fetch`. The signature of this method is identical to the [canonical `fetch`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).\n   *\n   * @param url The URL from which data should be fetched.\n   * @param init Optional parameters customizing the request, by specifying an HTTP method, headers, a body, etc. Follows the [WHATWG Fetch Standard](https://fetch.spec.whatwg.org/).\n   */\n  fetch = async (url: RequestInfo, init?: RequestInit): Promise<Response> => {\n    return this.clientAuthentication.fetch(url, {\n      ...init,\n      credentials: this.tmpFetchWithCookies\n        ? /* istanbul ignore next Simulating a cookie-enabled session in tests is too much work for a temporary, disabled-by-default workaround: */\n          \"include\"\n        : /* istanbul ignore next Simulating a cookie-enabled session in tests is too much work for a temporary, disabled-by-default workaround: */\n          init?.credentials,\n    });\n  };\n\n  /**\n   * An internal logout function, to control whether or not the logout signal\n   * should be sent, i.e. if the logout was user-initiated or is the result of\n   * an external event.\n   *\n   * @hidden\n   */\n  private internalLogout = async (emitSignal: boolean): Promise<void> => {\n    // Clearing this value means that silent refresh will no longer be attempted.\n    // In particular, in the case of a silent authentication error it prevents\n    // from getting stuck in an authentication retries loop.\n    window.localStorage.removeItem(KEY_CURRENT_SESSION);\n    await this.clientAuthentication.logout(this.info.sessionId);\n    this.info.isLoggedIn = false;\n    this.tmpFetchWithCookies = false;\n    if (emitSignal) {\n      this.emit(EVENTS.LOGOUT);\n    }\n  };\n\n  /**\n   * Logs the user out of the application. This does not log the user out of their Solid identity provider, and should not redirect the user away.\n   */\n  logout = async (): Promise<void> => this.internalLogout(true);\n\n  /**\n   * Completes the login process by processing the information provided by the\n   * Solid identity provider through redirect.\n   *\n   * @param options See {@see IHandleIncomingRedirectOptions}.\n   */\n  handleIncomingRedirect = async (\n    inputOptions: string | IHandleIncomingRedirectOptions = {}\n  ): Promise<ISessionInfo | undefined> => {\n    if (this.info.isLoggedIn) {\n      return this.info;\n    }\n\n    if (this.tokenRequestInProgress) {\n      return undefined;\n    }\n    const options =\n      typeof inputOptions === \"string\" ? { url: inputOptions } : inputOptions;\n    const url = options.url ?? window.location.href;\n\n    if (window.frameElement !== null) {\n      // This is being loaded from an iframe, so send the redirect\n      // URL to the parent window on the same origin.\n      postRedirectUrlToParent(url);\n      return undefined;\n    }\n\n    // Unfortunately, regular sessions are lost when the user refreshes the page or opens a new tab.\n    // While we're figuring out the API for a longer-term solution, as a temporary workaround some\n    // *resource* servers set a cookie that keeps the user logged in after authenticated requests,\n    // and expose the fact that they set it on a special endpoint.\n    // After login, we store that fact in LocalStorage. This means that we can now look for that\n    // data, and if present, indicate that the user is already logged in.\n    // Note that there are a lot of edge cases that won't work well with this approach, so it willl\n    // be removed in due time, and is disabled by default.\n    if (\n      options.useEssSession !== true ||\n      options.restorePreviousSession === true\n    ) {\n      window.localStorage.setItem(\n        \"tmp-resource-server-session-enabled\",\n        \"false\"\n      );\n    } else {\n      window.localStorage.setItem(\n        \"tmp-resource-server-session-enabled\",\n        \"true\"\n      );\n    }\n    const storedSessionCookieReference = window.localStorage.getItem(\n      \"tmp-resource-server-session-info\"\n    );\n    if (\n      typeof storedSessionCookieReference === \"string\" &&\n      options.restorePreviousSession !== true &&\n      options.useEssSession === true\n    ) {\n      // TOOD: Re-use the type used when writing this data:\n      // https://github.com/inrupt/solid-client-authn-js/pull/920/files#diff-659ac87dfd3711f4cfcea3c7bf6970980f4740fd59df45f04c7977bffaa23e98R118\n      // To keep temporary code together\n      // eslint-disable-next-line no-inner-declarations\n      function isValidSessionCookieReference(\n        reference: Record<string, unknown>\n      ): reference is ResourceServerSession {\n        const resourceServers = Object.keys(\n          (reference as ResourceServerSession).sessions ?? {}\n        );\n        return (\n          typeof (reference as ResourceServerSession).webId === \"string\" &&\n          resourceServers.length > 0 &&\n          typeof (reference as ResourceServerSession).sessions[\n            resourceServers[0]\n          ].expiration === \"number\"\n        );\n      }\n      const reference = JSON.parse(storedSessionCookieReference);\n      if (isValidSessionCookieReference(reference)) {\n        const resourceServers = Object.keys(reference.sessions);\n        const webIdOrigin = new URL(reference.webId).hostname;\n        const ownResourceServer = resourceServers.find((resourceServer) => {\n          return new URL(resourceServer).hostname === webIdOrigin;\n        });\n        // Usually the user's WebID is also a Resource server for them,\n        // so we pick the expiration time for that. If it doesn't exist,\n        // we just pick the first (and probably only) one:\n        const relevantServer = ownResourceServer ?? resourceServers[0];\n        // If the cookie is valid for fewer than five minutes,\n        // pretend it's not valid anymore already, to avoid small misalignments\n        // resulting in invalid states:\n        if (\n          reference.sessions[relevantServer].expiration - Date.now() >\n          5 * 60 * 1000\n        ) {\n          this.info.isLoggedIn = true;\n          this.info.webId = reference.webId;\n          this.tmpFetchWithCookies = true;\n          return this.info;\n        }\n      }\n    }\n    // end of temporary workaround.\n\n    this.tokenRequestInProgress = true;\n    const sessionInfo = await this.clientAuthentication.handleIncomingRedirect(\n      url,\n      this\n    );\n    if (isLoggedIn(sessionInfo)) {\n      this.setSessionInfo(sessionInfo);\n      const currentUrl = window.localStorage.getItem(KEY_CURRENT_URL);\n      if (currentUrl === null) {\n        // The login event can only be triggered **after** the user has been\n        // redirected from the IdP with access and ID tokens.\n        this.emit(EVENTS.LOGIN);\n      } else {\n        // If an URL is stored in local storage, we are being logged in after a\n        // silent authentication, so remove our currently stored URL location\n        // to clean up our state now that we are completing the re-login process.\n        window.localStorage.removeItem(KEY_CURRENT_URL);\n        this.emit(EVENTS.SESSION_RESTORED, currentUrl);\n      }\n    } else if (options.restorePreviousSession === true) {\n      // Silent authentication happens after a refresh, which means there are no\n      // OAuth params in the current location IRI. It can only succeed if a session\n      // was previously logged in, in which case its ID will be present with a known\n      // identifier in local storage.\n      // Check if we have a locally stored session ID...\n      const storedSessionId = window.localStorage.getItem(KEY_CURRENT_SESSION);\n      // ...if not, then there is no ID token, and so silent authentication cannot happen, but\n      // if we do have a stored session ID, attempt to re-authenticate now silently.\n      if (storedSessionId !== null) {\n        // TODO: iframe-based authentication being still experimental, it is disabled\n        // by default here. When it settles down, the following could be set to true,\n        // in which case the unresolving promise afterwards would need to be changed.\n        const attemptedSilentAuthentication = await silentlyAuthenticate(\n          storedSessionId,\n          this.clientAuthentication,\n          undefined,\n          this\n        );\n        // At this point, we know that the main window will imminently be redirected.\n        // However, this redirect is asynchronous and there is no way to halt execution\n        // until it happens precisely. That's why the current Promise simply does not\n        // resolve.\n        if (attemptedSilentAuthentication) {\n          return new Promise(() => {});\n        }\n      }\n    }\n    this.tokenRequestInProgress = false;\n    return sessionInfo;\n  };\n\n  /**\n   * Register a callback function to be called when a user completes login.\n   *\n   * The callback is called when {@link handleIncomingRedirect} completes successfully.\n   *\n   * @param callback The function called when a user completes login.\n   */\n  onLogin(callback: () => unknown): void {\n    this.on(EVENTS.LOGIN, callback);\n  }\n\n  /**\n   * Register a callback function to be called when a user logs out:\n   *\n   * @param callback The function called when a user completes logout.\n   */\n  onLogout(callback: () => unknown): void {\n    this.on(EVENTS.LOGOUT, callback);\n  }\n\n  /**\n   * Register a callback function to be called when a user logs out:\n   *\n   * @param callback The function called when an error occurs.\n   * @since 1.11.0\n   */\n  onError(\n    callback: (\n      error: string | null,\n      errorDescription?: string | null\n    ) => unknown\n  ): void {\n    this.on(EVENTS.ERROR, callback);\n  }\n\n  /**\n   * Register a callback function to be called when a session is restored.\n   *\n   * Note: the callback will be called with the saved value of the 'current URL'\n   * at the time the session was restored.\n   *\n   * @param callback The function called when a user's already logged-in session is restored, e.g., after a silent authentication is completed after a page refresh.\n   */\n  onSessionRestore(callback: (currentUrl: string) => unknown): void {\n    this.on(EVENTS.SESSION_RESTORED, callback);\n  }\n\n  /**\n   * Register a callback that runs when the session expires and can no longer\n   * make authenticated requests, but following a user logout.\n   * @param callback The function that runs on session expiration.\n   * @since 1.11.0\n   */\n  onSessionExpiration(callback: () => unknown): void {\n    this.on(EVENTS.SESSION_EXPIRED, callback);\n  }\n\n  private setSessionInfo(\n    sessionInfo: ISessionInfo & { isLoggedIn: true }\n  ): void {\n    this.info.isLoggedIn = sessionInfo.isLoggedIn;\n    this.info.webId = sessionInfo.webId;\n    this.info.sessionId = sessionInfo.sessionId;\n    this.info.expirationDate = sessionInfo.expirationDate;\n    this.on(EVENTS.SESSION_EXTENDED, (expiresIn: number) => {\n      this.info.expirationDate = Date.now() + expiresIn * 1000;\n    });\n  }\n}\n"]}},"error":null,"hash":"4d13e601c2b4c647671654b10ef5f861","cacheData":{"env":{}}}