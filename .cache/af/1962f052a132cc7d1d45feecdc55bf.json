{"id":"node_modules/@inrupt/solid-client-authn-core/dist/util/handlerPattern/AggregateHandler.js","dependencies":[{"name":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-core/dist/util/handlerPattern/AggregateHandler.js.map","includedInParent":true,"mtime":1652099631126},{"name":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-core/src/util/handlerPattern/AggregateHandler.ts","includedInParent":true,"mtime":1652099631174},{"name":"/Users/tdrave/demo-solid-app/package.json","includedInParent":true,"mtime":1652099771977},{"name":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-core/package.json","includedInParent":true,"mtime":1652099631124},{"name":"../../errors/InruptError","loc":{"line":6,"column":46,"index":262},"parent":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-core/dist/util/handlerPattern/AggregateHandler.js","resolved":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-core/dist/errors/InruptError.js"}],"generated":{"js":"\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst InruptError_1 = __importDefault(require(\"../../errors/InruptError\"));\nclass AggregateHandler {\n    constructor(handleables) {\n        this.handleables = handleables;\n    }\n    async getProperHandler(params) {\n        const canHandleList = await Promise.all(this.handleables.map((handleable) => handleable.canHandle(...params)));\n        for (let i = 0; i < canHandleList.length; i += 1) {\n            if (canHandleList[i]) {\n                return this.handleables[i];\n            }\n        }\n        return null;\n    }\n    async canHandle(...params) {\n        return (await this.getProperHandler(params)) !== null;\n    }\n    async handle(...params) {\n        const handler = await this.getProperHandler(params);\n        if (handler) {\n            return handler.handle(...params);\n        }\n        throw new InruptError_1.default(`[${this.constructor.name}] cannot find a suitable handler for: ${params\n            .map((param) => {\n            try {\n                return JSON.stringify(param);\n            }\n            catch (err) {\n                return param.toString();\n            }\n        })\n            .join(\", \")}`);\n    }\n}\nexports.default = AggregateHandler;\n"},"sourceMaps":{"js":{"version":3,"file":"AggregateHandler.js","sourceRoot":"","sources":["../../../src/util/handlerPattern/AggregateHandler.ts"],"names":[],"mappings":";;;;;AA8BA,2EAAmD;AAKnD,MAAqB,gBAAgB;IAGnC,YAAoB,WAAgC;QAAhC,gBAAW,GAAX,WAAW,CAAqB;IAAG,CAAC;IAOhD,KAAK,CAAC,gBAAgB,CAAC,MAAS;QAsBtC,MAAM,aAAa,GAAG,MAAM,OAAO,CAAC,GAAG,CACrC,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,UAAU,EAAE,EAAE,CAAC,UAAU,CAAC,SAAS,CAAC,GAAG,MAAM,CAAC,CAAC,CACtE,CAAC;QAEF,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,aAAa,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE;YAChD,IAAI,aAAa,CAAC,CAAC,CAAC,EAAE;gBACpB,OAAO,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;aAC5B;SACF;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAED,KAAK,CAAC,SAAS,CAAC,GAAG,MAAS;QAC1B,OAAO,CAAC,MAAM,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC,KAAK,IAAI,CAAC;IACxD,CAAC;IAED,KAAK,CAAC,MAAM,CAAC,GAAG,MAAS;QACvB,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC;QACpD,IAAI,OAAO,EAAE;YACX,OAAO,OAAO,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC;SAClC;QAED,MAAM,IAAI,qBAAW,CACnB,IAAI,IAAI,CAAC,WAAW,CAAC,IAAI,yCAAyC,MAAM;aACrE,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE;YACb,IAAI;gBACF,OAAO,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;aAC9B;YAAC,OAAO,GAAG,EAAE;gBAEZ,OAAQ,KAAa,CAAC,QAAQ,EAAE,CAAC;aAClC;QACH,CAAC,CAAC;aACD,IAAI,CAAC,IAAI,CAAC,EAAE,CAChB,CAAC;IACJ,CAAC;CACF;AAnED,mCAmEC","sourcesContent":["/*\n * Copyright 2022 Inrupt Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n * Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * @hidden\n * @packageDocumentation\n */\n\n/**\n * An abstract class that will select the first handler that can handle certain parameters\n */\nimport IHandleable from \"./IHandleable\";\nimport InruptError from \"../../errors/InruptError\";\n\n/**\n * @hidden\n */\nexport default class AggregateHandler<P extends Array<unknown>, R>\n  implements IHandleable<P, R>\n{\n  constructor(private handleables: IHandleable<P, R>[]) {}\n\n  /**\n   * Helper function that will asynchronously determine the proper handler to use. If multiple\n   * handlers can handle, it will choose the first one in the list\n   * @param params Paramerters to feed to the handler\n   */\n  private async getProperHandler(params: P): Promise<IHandleable<P, R> | null> {\n    // TODO : This function doesn't currently operate as described. Tests need to be written\n\n    // return new Promise<IHandleable<P, R> | null>((resolve, reject) => {\n    //  const resolvedValues: Array<boolean | null> = Array(this.handleables.length).map(() => null)\n    //   let numberResolved = 0\n    //   this.handleables.forEach(async (handleable: IHandleable<P, R>, index: number) => {\n    //     resolvedValues[index] = await handleable.canHandle(...params)\n    //     numberResolved++\n    //     let curResolvedValueIndex = 0\n    //     while (\n    //       resolvedValues[curResolvedValueIndex] !== null ||\n    //       resolvedValues[curResolvedValueIndex] !== undefined\n    //     ) {\n    //       if (resolvedValues[curResolvedValueIndex]) {\n    //         resolve(this.handleables[curResolvedValueIndex])\n    //       }\n    //       curResolvedValueIndex++\n    //     }\n    //   })\n    // })\n\n    const canHandleList = await Promise.all(\n      this.handleables.map((handleable) => handleable.canHandle(...params))\n    );\n\n    for (let i = 0; i < canHandleList.length; i += 1) {\n      if (canHandleList[i]) {\n        return this.handleables[i];\n      }\n    }\n    return null;\n  }\n\n  async canHandle(...params: P): Promise<boolean> {\n    return (await this.getProperHandler(params)) !== null;\n  }\n\n  async handle(...params: P): Promise<R> {\n    const handler = await this.getProperHandler(params);\n    if (handler) {\n      return handler.handle(...params);\n    }\n\n    throw new InruptError(\n      `[${this.constructor.name}] cannot find a suitable handler for: ${params\n        .map((param) => {\n          try {\n            return JSON.stringify(param);\n          } catch (err) {\n            /* eslint-disable  @typescript-eslint/no-explicit-any */\n            return (param as any).toString();\n          }\n        })\n        .join(\", \")}`\n    );\n  }\n}\n"]}},"error":null,"hash":"d63822dbb2ce4e6afb63df9021f82b04","cacheData":{"env":{}}}