{"id":"node_modules/@inrupt/solid-client-authn-core/dist/errors/InruptError.js","dependencies":[{"name":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-core/dist/errors/InruptError.js.map","includedInParent":true,"mtime":1652099631148},{"name":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-core/src/errors/InruptError.ts","includedInParent":true,"mtime":1652099631230},{"name":"/Users/tdrave/demo-solid-app/package.json","includedInParent":true,"mtime":1652099771977},{"name":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-core/package.json","includedInParent":true,"mtime":1652099631124}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass InruptError extends Error {\n    constructor(messageOrIri, messageParams, appendErrorIri = true) {\n        super(typeof messageOrIri === \"string\"\n            ? InruptError.substituteParams(messageOrIri, messageParams)\n            : InruptError.appendErrorIri(InruptError.lookupErrorIri(messageOrIri, messageParams), messageOrIri, appendErrorIri));\n    }\n    httpResponse(httpErrorResponse, appendHttpDetails = true) {\n        this.message = InruptError.appendHttpResponseDetails(this.message, httpErrorResponse, appendHttpDetails);\n        this.httpErrorResponse = httpErrorResponse;\n        return this;\n    }\n    hasHttpResponse() {\n        return this.httpErrorResponse !== undefined;\n    }\n    getHttpResponse() {\n        return this.httpErrorResponse;\n    }\n    getHttpStatusCode() {\n        if (this.httpErrorResponse === undefined) {\n            throw new InruptError(\"This InruptError was not provided with a HTTP response - so we can't get its HTTP Status Code.\");\n        }\n        return this.httpErrorResponse.status;\n    }\n    getHttpStatusText() {\n        if (this.httpErrorResponse === undefined) {\n            throw new InruptError(\"This InruptError was not provided with a HTTP response - so we can't get its HTTP Status Text!\");\n        }\n        return this.httpErrorResponse.statusText;\n    }\n    static determineIfVocabTerm(value) {\n        if (value.strict !== undefined) {\n            return true;\n        }\n        return false;\n    }\n    static lookupErrorIri(iri, messageParams) {\n        if (InruptError.determineIfVocabTerm(iri)) {\n            const message = messageParams === undefined\n                ? iri.message\n                : iri.messageParams(...messageParams);\n            return message === undefined\n                ? `Looked up error message IRI [${iri.value}], but found no message value.`\n                : message;\n        }\n        return `Error message looked up at: [${iri.value}]${messageParams === undefined\n            ? \"\"\n            : `, with params [${messageParams.toString()}]`}`;\n    }\n    static appendHttpResponseDetails(message, response, append) {\n        if (append && typeof response !== \"undefined\") {\n            return `${message} HTTP details: status code [${response.status}], status text [${response.statusText}].`;\n        }\n        return message;\n    }\n    static appendErrorIri(message, iri, append) {\n        return append ? `${message} Error IRI: [${iri.value}].` : message;\n    }\n    static substituteParams(message, params) {\n        let fullMessage = message;\n        if (params !== undefined) {\n            const paramsRequired = message.split(\"{{\").length - 1;\n            if (paramsRequired !== params.length) {\n                throw new Error(`Setting parameters on message [${message}], but it requires [${paramsRequired}] params and we received [${params.length}].`);\n            }\n            for (let i = 0; i < params.length; i += 1) {\n                const marker = `{{${i}}}`;\n                fullMessage = fullMessage.replace(marker, params[i]);\n            }\n        }\n        return fullMessage;\n    }\n}\nexports.default = InruptError;\n"},"sourceMaps":{"js":{"version":3,"file":"InruptError.js","sourceRoot":"","sources":["../../src/errors/InruptError.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2022 Inrupt Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n * Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * @hidden\n * The generic Inrupt error class, that simply extends the regular JavaScript\n * [[Error]] object but provides extra capabilities and meta-data (e.g.\n * potentially data from a HTTP response, or with data from an RDF vocabulary\n * (which may be imported locally, or looked up dynamically at runtime)).\n *\n * Error Identifiers\n *   Our error class supports the notion of globally unique, dereferenceable\n *   error identifiers in the form of IRIs.\n *\n * Parameterized error messages\n *   This class supports error messages with positional placeholders that can be\n *   replaced by developer-provided parameter values at runtime.\n *\n * Wrapped Errors (Coming soon!)\n *   Similar to how Java supports the notion of wrapped exceptions, our error\n *   class implementation supports the ability to wrap [[Error]]s.\n *\n * HTTP errors:\n *   This class provides a very convenient means to provide a HTTP response,\n *   the details from which can be appended to error message strings, and the\n *   response itself retrieved directly by consumers of instances of this class.\n * @packageDocumentation\n */\n\nimport { VocabTerm, NamedNode } from \"@inrupt/solid-common-vocab\";\n\nexport default class InruptError extends Error {\n  // For the common case of HTTP errors, we can store the HTTP response to allow\n  // consumers of this error instance to access it directly.\n  // NOTE: we specifically stipulate that we expect the HTTP response to be an\n  // error response!\n  private httpErrorResponse?: Response & { ok: false };\n\n  constructor(\n    messageOrIri: string | NamedNode | VocabTerm,\n    messageParams?: string[],\n    appendErrorIri = true\n  ) {\n    super(\n      typeof messageOrIri === \"string\"\n        ? InruptError.substituteParams(messageOrIri, messageParams)\n        : InruptError.appendErrorIri(\n            InruptError.lookupErrorIri(messageOrIri, messageParams),\n            messageOrIri as NamedNode,\n            appendErrorIri\n          )\n    );\n  }\n\n  /**\n   * Allows us provide a HTTP response, and to specify if we want details from\n   * that response to be appended to our error message string. We also preserve\n   * specific state from that response object to allow consumers of this error\n   * to directly access those if they wish.\n   *\n   * @param httpErrorResponse\n   * @param appendHttpDetails\n   */\n  public httpResponse(\n    httpErrorResponse: Response & { ok: false },\n    appendHttpDetails = true\n  ): InruptError {\n    this.message = InruptError.appendHttpResponseDetails(\n      this.message,\n      httpErrorResponse,\n      appendHttpDetails\n    );\n\n    // Preserve the HTTP response (in case the consumer of this error wishes to\n    // access its details directly themselves).\n    this.httpErrorResponse = httpErrorResponse;\n\n    return this;\n  }\n\n  hasHttpResponse(): boolean {\n    return this.httpErrorResponse !== undefined;\n  }\n\n  getHttpResponse(): (Response & { ok: false }) | undefined {\n    return this.httpErrorResponse;\n  }\n\n  getHttpStatusCode(): number {\n    if (this.httpErrorResponse === undefined) {\n      throw new InruptError(\n        \"This InruptError was not provided with a HTTP response - so we can't get its HTTP Status Code.\"\n      );\n    }\n\n    return this.httpErrorResponse.status;\n  }\n\n  getHttpStatusText(): string {\n    if (this.httpErrorResponse === undefined) {\n      throw new InruptError(\n        \"This InruptError was not provided with a HTTP response - so we can't get its HTTP Status Text!\"\n      );\n    }\n\n    return this.httpErrorResponse.statusText;\n  }\n\n  static determineIfVocabTerm(\n    value: NamedNode | VocabTerm\n  ): value is VocabTerm {\n    if ((value as VocabTerm).strict !== undefined) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Given the IRI for an error message term, first check if it's a local\n   * Vocab Term (in which case we expect the error messages (in potentially\n   * multiple languages) to be accessible directly.\n   * If however the IRI is just a raw IRI, then attempt to lookup the term\n   * dynamically by simply de-referencing it and asking for RDF back (which we\n   * then need to parse and extract the relevant message string).\n   *\n   * NOTE: if we find the referenced term, but it has no explicit message\n   * values associated with it (e.g. the term `https://schema.org/Person` would\n   * resolve, but it has no Vocab Term-defined 'message' triples associated with\n   * it), then we return a fixed message string explaining this, but that\n   * includes the error IRI and the provided parameters.\n   *\n   * @param iri the IRI of the error message term from an RDF vocabulary\n   * @param messageParams parameters to replace expected placeholders in the message string\n   */\n  static lookupErrorIri(\n    iri: NamedNode | VocabTerm,\n    messageParams?: string[]\n  ): string {\n    if (InruptError.determineIfVocabTerm(iri)) {\n      const message =\n        messageParams === undefined\n          ? iri.message\n          : iri.messageParams(...messageParams);\n\n      return message === undefined\n        ? `Looked up error message IRI [${iri.value}], but found no message value.`\n        : message;\n    }\n\n    return `Error message looked up at: [${iri.value}]${\n      messageParams === undefined\n        ? \"\"\n        : `, with params [${messageParams.toString()}]`\n    }`;\n  }\n\n  /**\n   * Convenience method to append certain HTTP response details to our error\n   * message (e.g. the HTTP status code, or the status text).\n   *\n   * @param message the message string to append to\n   * @param response the optional HTTP response\n   * @param append flag telling us to append or not\n   */\n  static appendHttpResponseDetails(\n    message: string,\n    response: Response | undefined,\n    append: boolean\n  ): string {\n    if (append && typeof response !== \"undefined\") {\n      return `${message} HTTP details: status code [${response.status}], status text [${response.statusText}].`;\n    }\n\n    return message;\n  }\n\n  /**\n   * Convenience method to append the error term's IRI value to our error\n   * message (which can be a very helpful reference, since it's basically the ID\n   * of the error message itself).\n   *\n   * @param message the message string to append to\n   * @param iri the IRI of the error term\n   * @param append flag telling us to append or not\n   */\n  static appendErrorIri(\n    message: string,\n    iri: NamedNode,\n    append: boolean\n  ): string {\n    return append ? `${message} Error IRI: [${iri.value}].` : message;\n  }\n\n  /**\n   * Scans the specified message returning a copy with all placeholders replaced\n   * with their corresponding parameter value.\n   *\n   * Note: If the number of parameters provided does not exactly match the\n   * number of placeholders, we throw an exception explaining this (as we\n   * consider it a programmer error).\n   *\n   * @param message the message within which to replace placeholders\n   * @param params the parameters to replaces the placeholders\n   */\n  static substituteParams(message: string, params?: string[]): string {\n    let fullMessage = message;\n    if (params !== undefined) {\n      const paramsRequired = message.split(\"{{\").length - 1;\n      if (paramsRequired !== params.length) {\n        throw new Error(\n          `Setting parameters on message [${message}], but it requires [${paramsRequired}] params and we received [${params.length}].`\n        );\n      }\n\n      for (let i = 0; i < params.length; i += 1) {\n        const marker = `{{${i}}}`;\n        fullMessage = fullMessage.replace(marker, params[i]);\n      }\n    }\n\n    return fullMessage;\n  }\n}\n"]}},"error":null,"hash":"7a66ad7cfc9bc43b903f6269e441ab28","cacheData":{"env":{}}}