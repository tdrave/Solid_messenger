"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
const jose_1 = require("jose");
const events_1 = require("events");
const cross_fetch_1 = require("cross-fetch");
const fetchFactory_1 = require("./fetchFactory");
const TokenRefresher_1 = require("../login/oidc/refresh/__mocks__/TokenRefresher");
const constant_1 = require("../constant");
const OidcProviderError_1 = require("../errors/OidcProviderError");
const InvalidResponseError_1 = require("../errors/InvalidResponseError");
globals_1.jest.mock("cross-fetch", () => {
    return {
        ...globals_1.jest.requireActual("cross-fetch"),
        default: globals_1.jest.fn(),
        fetch: globals_1.jest.fn(),
    };
});
const mockNotRedirectedResponse = () => {
    const mockedResponse = new cross_fetch_1.Response(undefined);
    globals_1.jest.spyOn(mockedResponse, "redirected", "get").mockReturnValueOnce(false);
    globals_1.jest
        .spyOn(mockedResponse, "url", "get")
        .mockReturnValueOnce("http://some.url");
    return mockedResponse;
};
let publicKey;
let privateKey;
const mockJwk = async () => {
    if (typeof publicKey === "undefined" || typeof privateKey === "undefined") {
        const generatedPair = await (0, jose_1.generateKeyPair)("ES256");
        publicKey = generatedPair.publicKey;
        privateKey = generatedPair.privateKey;
    }
    return {
        publicKey,
        privateKey,
    };
};
const mockKeyPair = async () => {
    const { privateKey: prvt, publicKey: pblc } = await mockJwk();
    const dpopKeyPair = {
        privateKey: prvt,
        publicKey: await (0, jose_1.exportJWK)(pblc),
    };
    dpopKeyPair.publicKey.alg = "ES256";
    return dpopKeyPair;
};
const mockFetch = (response, url) => {
    const { fetch } = globals_1.jest.requireMock("cross-fetch");
    const mockedResponse = response;
    globals_1.jest.spyOn(mockedResponse, "url", "get").mockReturnValue(url);
    fetch.mockResolvedValueOnce(mockedResponse);
    return fetch;
};
(0, globals_1.describe)("buildAuthenticatedFetch", () => {
    (0, globals_1.it)("builds a DPoP fetch if a DPoP key is provided", async () => {
        var _a;
        const mockedFetch = mockFetch(new cross_fetch_1.Response(undefined, {
            status: 401,
        }), "https://my.pod/resource");
        const keylikePair = await mockJwk();
        const myFetch = await (0, fetchFactory_1.buildAuthenticatedFetch)(mockedFetch, "myToken", {
            dpopKey: {
                privateKey: keylikePair.privateKey,
                publicKey: await (0, jose_1.exportJWK)(keylikePair.publicKey),
            },
            refreshOptions: {
                refreshToken: "some refresh token",
                sessionId: "mySession",
                tokenRefresher: {
                    refresh: globals_1.jest.fn(),
                },
            },
        });
        await myFetch("https://my.pod/resource");
        (0, globals_1.expect)(mockedFetch.mock.calls[0][0]).toBe("https://my.pod/resource");
        const headers = new Headers((_a = mockedFetch.mock.calls[0][1]) === null || _a === void 0 ? void 0 : _a.headers);
        const decodedHeader = await (0, jose_1.jwtVerify)(headers.get("DPoP"), (await mockJwk()).publicKey);
        (0, globals_1.expect)(decodedHeader.payload).toMatchObject({
            htu: "https://my.pod/resource",
        });
    });
    (0, globals_1.it)("builds the appropriate DPoP header for a given HTTP verb.", async () => {
        var _a;
        const mockedFetch = mockFetch(mockNotRedirectedResponse(), "https://my.pod/resource");
        const myFetch = await (0, fetchFactory_1.buildAuthenticatedFetch)(mockedFetch, "myToken", {
            dpopKey: await mockKeyPair(),
        });
        await myFetch("http://some.url", {
            method: "POST",
        });
        const headers = new Headers((_a = mockedFetch.mock.calls[0][1]) === null || _a === void 0 ? void 0 : _a.headers);
        const { payload } = await (0, jose_1.jwtVerify)(headers.get("DPoP"), (await mockKeyPair()).privateKey);
        (0, globals_1.expect)(payload.htu).toBe("http://some.url/");
        (0, globals_1.expect)(payload.htm).toBe("POST");
    });
    (0, globals_1.it)("builds a Bearer fetch if no DPoP key is provided", async () => {
        var _a, _b;
        const mockedFetch = mockFetch(new cross_fetch_1.Response(undefined, { status: 401 }), "https://my.pod/resource");
        const myFetch = await (0, fetchFactory_1.buildAuthenticatedFetch)(mockedFetch, "myToken", undefined);
        await myFetch("https://my.pod/resource");
        (0, globals_1.expect)(mockedFetch.mock.calls[0][0]).toBe("https://my.pod/resource");
        const headers = new Headers((_a = mockedFetch.mock.calls[0][1]) === null || _a === void 0 ? void 0 : _a.headers);
        (0, globals_1.expect)((_b = headers.get("Authorization")) === null || _b === void 0 ? void 0 : _b.startsWith("Bearer")).toBe(true);
    });
    (0, globals_1.it)("returns a fetch that rebuilds the DPoP token if redirected", async () => {
        var _a;
        const mockedFetch = mockFetch(new cross_fetch_1.Response(undefined, { status: 403 }), "https://my.pod/container/");
        mockedFetch.mockResolvedValueOnce({
            url: "https://my.pod/container/",
            ok: true,
            status: 200,
        });
        const myFetch = await (0, fetchFactory_1.buildAuthenticatedFetch)(mockedFetch, "myToken", {
            dpopKey: await mockKeyPair(),
        });
        await myFetch("https://my.pod/container");
        (0, globals_1.expect)(mockedFetch.mock.calls[1][0]).toBe("https://my.pod/container/");
        const headers = new Headers((_a = mockedFetch.mock.calls[1][1]) === null || _a === void 0 ? void 0 : _a.headers);
        const { payload } = await (0, jose_1.jwtVerify)(headers.get("DPoP"), (await mockKeyPair()).privateKey);
        (0, globals_1.expect)(payload.htu).toBe("https://my.pod/container/");
    });
    (0, globals_1.it)("returns a fetch that does not retry fetching with a Bearer token if redirected", async () => {
        const mockedFetch = mockFetch(new cross_fetch_1.Response(undefined, { status: 403 }), "https://my.pod/container/");
        const myFetch = await (0, fetchFactory_1.buildAuthenticatedFetch)(mockedFetch, "myToken");
        const response = await myFetch("https://my.pod/container");
        (0, globals_1.expect)(response.status).toBe(403);
        (0, globals_1.expect)(mockedFetch.mock.calls).toHaveLength(1);
    });
    (0, globals_1.it)("returns a fetch preserving optional headers passed as a map", async () => {
        var _a;
        const mockedFetch = mockFetch(mockNotRedirectedResponse(), "https://my.pod/container/");
        const myFetch = await (0, fetchFactory_1.buildAuthenticatedFetch)(mockedFetch, "myToken", undefined);
        await myFetch("someUrl", { headers: { someHeader: "SomeValue" } });
        const headers = new Headers((_a = mockedFetch.mock.calls[0][1]) === null || _a === void 0 ? void 0 : _a.headers);
        (0, globals_1.expect)(headers.get("Authorization")).toBe("Bearer myToken");
        (0, globals_1.expect)(headers.get("someHeader")).toBe("SomeValue");
    });
    (0, globals_1.it)("returns a fetch preserving optional headers passed as a Header object", async () => {
        var _a;
        const mockedFetch = mockFetch(mockNotRedirectedResponse(), "https://my.pod/container/");
        const myFetch = await (0, fetchFactory_1.buildAuthenticatedFetch)(mockedFetch, "myToken", undefined);
        await myFetch("someUrl", {
            headers: new Headers({ someHeader: "SomeValue" }),
        });
        const headers = new Headers((_a = mockedFetch.mock.calls[0][1]) === null || _a === void 0 ? void 0 : _a.headers);
        (0, globals_1.expect)(headers.get("Authorization")).toBe("Bearer myToken");
        (0, globals_1.expect)(headers.get("someHeader")).toBe("SomeValue");
    });
    (0, globals_1.it)("returns a fetch overriding any pre-existing Authorization or DPoP headers", async () => {
        var _a;
        const mockedFetch = mockFetch(mockNotRedirectedResponse(), "https://my.pod/container/");
        const myFetch = await (0, fetchFactory_1.buildAuthenticatedFetch)(mockedFetch, "myToken", {
            dpopKey: await mockKeyPair(),
        });
        await myFetch("http://some.url", {
            headers: {
                Authorization: "some token",
                DPoP: "some header",
            },
        });
        const headers = new Headers((_a = mockedFetch.mock.calls[0][1]) === null || _a === void 0 ? void 0 : _a.headers);
        (0, globals_1.expect)(headers.get("Authorization")).toBe("DPoP myToken");
    });
    (0, globals_1.it)("does not retry a **redirected** fetch if the error is not auth-related", async () => {
        const mockedFetch = mockFetch(new cross_fetch_1.Response(undefined, { status: 400 }), "https://my.pod/container/");
        const myFetch = await (0, fetchFactory_1.buildAuthenticatedFetch)(mockedFetch, "myToken", {
            dpopKey: await mockKeyPair(),
        });
        const response = await myFetch("https://my.pod/container");
        (0, globals_1.expect)(mockedFetch.mock.calls).toHaveLength(1);
        (0, globals_1.expect)(response.status).toBe(400);
    });
    (0, globals_1.it)("returns the initial response in case of non-redirected auth error", async () => {
        const mockedFetch = mockFetch(new cross_fetch_1.Response(undefined, { status: 401 }), "https://my.pod/container/");
        const myFetch = await (0, fetchFactory_1.buildAuthenticatedFetch)(mockedFetch, "myToken", {
            refreshOptions: {
                refreshToken: "some refresh token",
                sessionId: "mySession",
                tokenRefresher: {
                    refresh: () => {
                        throw new Error("Some error");
                    },
                },
            },
        });
        const response = await myFetch("someUrl");
        (0, globals_1.expect)(response.status).toBe(401);
    });
    function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    }
    (0, globals_1.it)("refreshes the token before it expires", async () => {
        const { fetch: mockedFetch } = globals_1.jest.requireMock("cross-fetch");
        const mockRefresher = (0, TokenRefresher_1.mockDefaultTokenRefresher)();
        await (0, fetchFactory_1.buildAuthenticatedFetch)(mockedFetch, "myToken", {
            refreshOptions: {
                refreshToken: "some refresh token",
                sessionId: "mySession",
                tokenRefresher: mockRefresher,
            },
            expiresIn: 6,
        });
        (0, globals_1.expect)(mockRefresher.refresh).not.toHaveBeenCalled();
        await sleep(500);
        (0, globals_1.expect)(mockRefresher.refresh).not.toHaveBeenCalled();
        await sleep(500);
        (0, globals_1.expect)(mockRefresher.refresh).toHaveBeenCalled();
    });
    (0, globals_1.it)("sets a default timeout if the OIDC provider did not return one", async () => {
        const { fetch: mockedFetch } = globals_1.jest.requireMock("cross-fetch");
        const mockRefresher = (0, TokenRefresher_1.mockDefaultTokenRefresher)();
        const spyTimeout = globals_1.jest.spyOn(global, "setTimeout");
        await (0, fetchFactory_1.buildAuthenticatedFetch)(mockedFetch, "myToken", {
            refreshOptions: {
                refreshToken: "some refresh token",
                sessionId: "mySession",
                tokenRefresher: mockRefresher,
            },
        });
        (0, globals_1.expect)(spyTimeout).toHaveBeenLastCalledWith(globals_1.expect.any(Function), fetchFactory_1.DEFAULT_EXPIRATION_TIME_SECONDS * 1000);
    });
    (0, globals_1.it)("does not rebind the DPoP token on refresh", async () => {
        const { fetch: mockedFetch } = globals_1.jest.requireMock("cross-fetch");
        const keylikePair = await mockJwk();
        const mockedTokenRefresher = {
            refresh: globals_1.jest
                .fn()
                .mockResolvedValueOnce({
                ...(0, TokenRefresher_1.mockDefaultTokenSet)(),
                refreshToken: "some rotated refresh token",
                expiresIn: 0,
            })
                .mockResolvedValue({ ...(0, TokenRefresher_1.mockDefaultTokenSet)(), expiresIn: 1000 }),
        };
        await (0, fetchFactory_1.buildAuthenticatedFetch)(mockedFetch, "myToken", {
            dpopKey: {
                privateKey: keylikePair.privateKey,
                publicKey: await (0, jose_1.exportJWK)(keylikePair.publicKey),
            },
            refreshOptions: {
                refreshToken: "some refresh token",
                sessionId: "mySession",
                tokenRefresher: mockedTokenRefresher,
            },
            expiresIn: 0,
        });
        await sleep(200);
        (0, globals_1.expect)(mockedTokenRefresher.refresh).toHaveBeenCalledWith(globals_1.expect.anything(), "some refresh token", {
            privateKey: keylikePair.privateKey,
            publicKey: await (0, jose_1.exportJWK)(keylikePair.publicKey),
        });
    });
    (0, globals_1.it)("sets up the timeout on refresh so that the tokens keep being valid", async () => {
        const { fetch: mockedFetch } = globals_1.jest.requireMock("cross-fetch");
        const mockRefresher = (0, TokenRefresher_1.mockTokenRefresher)({
            ...(0, TokenRefresher_1.mockDefaultTokenSet)(),
            expiresIn: 7,
        });
        const spyTimeout = globals_1.jest.spyOn(global, "setTimeout");
        const mockedEmitter = new events_1.EventEmitter();
        const spiedEmit = globals_1.jest.spyOn(mockedEmitter, "emit");
        await (0, fetchFactory_1.buildAuthenticatedFetch)(mockedFetch, "myToken", {
            refreshOptions: {
                refreshToken: "some refresh token",
                sessionId: "mySession",
                tokenRefresher: mockRefresher,
            },
            expiresIn: 6,
            eventEmitter: mockedEmitter,
        });
        await sleep(1000);
        (0, globals_1.expect)(mockRefresher.refresh).toHaveBeenCalled();
        (0, globals_1.expect)(spyTimeout).toHaveBeenLastCalledWith(globals_1.expect.any(Function), 2 * 1000);
        (0, globals_1.expect)(spiedEmit).toHaveBeenCalledWith(constant_1.EVENTS.TIMEOUT_SET, globals_1.expect.anything());
    });
    (0, globals_1.it)("sets a default timeout on refresh if the OIDC provider does not return one", async () => {
        const { fetch: mockedFetch } = globals_1.jest.requireMock("cross-fetch");
        const mockRefresher = (0, TokenRefresher_1.mockTokenRefresher)({
            ...(0, TokenRefresher_1.mockDefaultTokenSet)(),
            expiresIn: undefined,
        });
        const spyTimeout = globals_1.jest.spyOn(global, "setTimeout");
        await (0, fetchFactory_1.buildAuthenticatedFetch)(mockedFetch, "myToken", {
            refreshOptions: {
                refreshToken: "some refresh token",
                sessionId: "mySession",
                tokenRefresher: mockRefresher,
            },
            expiresIn: 6,
        });
        await sleep(1000);
        (0, globals_1.expect)(mockRefresher.refresh).toHaveBeenCalled();
        (0, globals_1.expect)(spyTimeout).toHaveBeenLastCalledWith(globals_1.expect.any(Function), fetchFactory_1.DEFAULT_EXPIRATION_TIME_SECONDS * 1000);
    });
    (0, globals_1.it)("calls the provided callback when the access token is refreshed", async () => {
        const { fetch: mockedFetch } = globals_1.jest.requireMock("cross-fetch");
        const tokenSet = (0, TokenRefresher_1.mockDefaultTokenSet)();
        const mockedFreshener = (0, TokenRefresher_1.mockTokenRefresher)({
            ...tokenSet,
            expiresIn: 1800,
        });
        const eventEmitter = new events_1.EventEmitter();
        const spiedEmit = globals_1.jest.spyOn(eventEmitter, "emit");
        await (0, fetchFactory_1.buildAuthenticatedFetch)(mockedFetch, "myToken", {
            refreshOptions: {
                refreshToken: "some refresh token",
                sessionId: "mySession",
                tokenRefresher: mockedFreshener,
            },
            eventEmitter,
            expiresIn: 0,
        });
        await sleep(200);
        (0, globals_1.expect)(spiedEmit).toHaveBeenCalledWith(constant_1.EVENTS.SESSION_EXTENDED, 1800);
    });
    (0, globals_1.it)("calls the provided callback when a new refresh token is issued", async () => {
        const { fetch: mockedFetch } = globals_1.jest.requireMock("cross-fetch");
        const tokenSet = (0, TokenRefresher_1.mockDefaultTokenSet)();
        tokenSet.refreshToken = "some rotated refresh token";
        const mockedFreshener = (0, TokenRefresher_1.mockTokenRefresher)(tokenSet);
        const eventEmitter = new events_1.EventEmitter();
        const spiedEmit = globals_1.jest.spyOn(eventEmitter, "emit");
        await (0, fetchFactory_1.buildAuthenticatedFetch)(mockedFetch, "myToken", {
            refreshOptions: {
                refreshToken: "some refresh token",
                sessionId: "mySession",
                tokenRefresher: mockedFreshener,
            },
            eventEmitter,
            expiresIn: 0,
        });
        await sleep(200);
        (0, globals_1.expect)(spiedEmit).toHaveBeenCalledWith(constant_1.EVENTS.NEW_REFRESH_TOKEN, "some rotated refresh token");
    });
    (0, globals_1.it)("rotates the refresh token if a new one is issued", async () => {
        const { fetch: mockedFetch } = globals_1.jest.requireMock("cross-fetch");
        const mockedTokenRefresher = {
            refresh: globals_1.jest
                .fn()
                .mockResolvedValueOnce({
                ...(0, TokenRefresher_1.mockDefaultTokenSet)(),
                refreshToken: "some rotated refresh token",
                expiresIn: 0,
            })
                .mockResolvedValue({ ...(0, TokenRefresher_1.mockDefaultTokenSet)(), expiresIn: 1000 }),
        };
        const refreshCall = globals_1.jest.spyOn(mockedTokenRefresher, "refresh");
        await (0, fetchFactory_1.buildAuthenticatedFetch)(mockedFetch, "myToken", {
            refreshOptions: {
                refreshToken: "some refresh token",
                sessionId: "mySession",
                tokenRefresher: mockedTokenRefresher,
            },
            expiresIn: 0,
        });
        await sleep(200);
        (0, globals_1.expect)(refreshCall.mock.calls[1][1]).toBe("some rotated refresh token");
    });
    (0, globals_1.it)("emits the appropriate events when refreshing the token fails", async () => {
        const { fetch: mockedFetch } = globals_1.jest.requireMock("cross-fetch");
        const mockedFreshener = (0, TokenRefresher_1.mockTokenRefresher)((0, TokenRefresher_1.mockDefaultTokenSet)());
        mockedFreshener.refresh = globals_1.jest
            .fn()
            .mockRejectedValueOnce(new OidcProviderError_1.OidcProviderError("Some error message", "error_identifier", "Some error description"));
        const mockEmitter = new events_1.EventEmitter();
        mockEmitter.on(constant_1.EVENTS.ERROR, globals_1.jest.fn());
        const spiedEmit = globals_1.jest.spyOn(mockEmitter, "emit");
        await (0, fetchFactory_1.buildAuthenticatedFetch)(mockedFetch, "myToken", {
            refreshOptions: {
                refreshToken: "some refresh token",
                sessionId: "mySession",
                tokenRefresher: mockedFreshener,
            },
            expiresIn: 0,
            eventEmitter: mockEmitter,
        });
        await sleep(200);
        (0, globals_1.expect)(spiedEmit).toHaveBeenCalledTimes(3);
        (0, globals_1.expect)(spiedEmit).toHaveBeenCalledWith(constant_1.EVENTS.TIMEOUT_SET, globals_1.expect.anything());
        (0, globals_1.expect)(spiedEmit).toHaveBeenCalledWith(constant_1.EVENTS.SESSION_EXPIRED);
        (0, globals_1.expect)(spiedEmit).toHaveBeenCalledWith(constant_1.EVENTS.ERROR, "error_identifier", "Some error description");
    });
    (0, globals_1.it)("emits the appropriate events when an unexpected response is received", async () => {
        const { fetch: mockedFetch } = globals_1.jest.requireMock("cross-fetch");
        const mockedFreshener = (0, TokenRefresher_1.mockTokenRefresher)((0, TokenRefresher_1.mockDefaultTokenSet)());
        mockedFreshener.refresh = globals_1.jest
            .fn()
            .mockRejectedValueOnce(new InvalidResponseError_1.InvalidResponseError(["access_token"]));
        const mockEmitter = new events_1.EventEmitter();
        const spiedEmit = globals_1.jest.spyOn(mockEmitter, "emit");
        await (0, fetchFactory_1.buildAuthenticatedFetch)(mockedFetch, "myToken", {
            refreshOptions: {
                refreshToken: "some refresh token",
                sessionId: "mySession",
                tokenRefresher: mockedFreshener,
            },
            expiresIn: 0,
            eventEmitter: mockEmitter,
        });
        await sleep(100);
        (0, globals_1.expect)(spiedEmit).toHaveBeenCalledTimes(2);
        (0, globals_1.expect)(spiedEmit).toHaveBeenCalledWith(constant_1.EVENTS.TIMEOUT_SET, globals_1.expect.anything());
        (0, globals_1.expect)(spiedEmit).toHaveBeenCalledWith(constant_1.EVENTS.SESSION_EXPIRED);
    });
    (0, globals_1.it)("emits the appropriate events when the access token expires and may not be refreshed", async () => {
        const { fetch: mockedFetch } = globals_1.jest.requireMock("cross-fetch");
        const mockedFreshener = (0, TokenRefresher_1.mockTokenRefresher)((0, TokenRefresher_1.mockDefaultTokenSet)());
        mockedFreshener.refresh = globals_1.jest
            .fn()
            .mockRejectedValueOnce(new InvalidResponseError_1.InvalidResponseError(["access_token"]));
        const mockEmitter = new events_1.EventEmitter();
        const spiedEmit = globals_1.jest.spyOn(mockEmitter, "emit");
        await (0, fetchFactory_1.buildAuthenticatedFetch)(mockedFetch, "myToken", {
            expiresIn: 0,
            eventEmitter: mockEmitter,
        });
        await sleep(100);
        (0, globals_1.expect)(spiedEmit).toHaveBeenCalledTimes(2);
        (0, globals_1.expect)(spiedEmit).toHaveBeenCalledWith(constant_1.EVENTS.TIMEOUT_SET, globals_1.expect.anything());
        (0, globals_1.expect)(spiedEmit).toHaveBeenCalledWith(constant_1.EVENTS.SESSION_EXPIRED);
    });
    (0, globals_1.it)("does not schedule any callback to be called if no event can be fired", async () => {
        const { fetch: mockedFetch } = globals_1.jest.requireMock("cross-fetch");
        const spyTimeout = globals_1.jest.spyOn(global, "setTimeout");
        await (0, fetchFactory_1.buildAuthenticatedFetch)(mockedFetch, "myToken");
        await sleep(100);
        (0, globals_1.expect)(spyTimeout).toHaveBeenCalledTimes(1);
    });
});
//# sourceMappingURL=fetchFactory.spec.js.map