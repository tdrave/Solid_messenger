"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
const AggregateHandler_1 = __importDefault(require("./AggregateHandler"));
(0, globals_1.describe)("AggregateHandler", () => {
    class AggregateMockHandler extends AggregateHandler_1.default {
        constructor(mockHandlers) {
            super(mockHandlers);
        }
    }
    function initMocks(configs) {
        const mockHandlerInfo = configs.map((config) => {
            const canHandleFunction = globals_1.jest.fn(async (_input) => {
                return new Promise((resolve, _reject) => {
                    setTimeout(() => resolve(config.canHandle), config.executeTime);
                });
            });
            const handleFunction = globals_1.jest.fn(async (_input) => {
                return new Promise((resolve, _reject) => {
                    setTimeout(() => resolve(config.toReturn), config.executeTime);
                });
            });
            const mock = globals_1.jest.fn(() => ({
                canHandle: canHandleFunction,
                handle: handleFunction,
            }));
            return {
                canHandleFunction,
                handleFunction,
                mock,
            };
        });
        const aggregateMockHandler = new AggregateMockHandler(mockHandlerInfo.map((info) => info.mock()));
        return {
            mockHandlerInfo,
            aggregateMockHandler,
        };
    }
    (0, globals_1.describe)("canHandle", () => {
        (0, globals_1.it)("should return correct handler", async () => {
            const mocks = initMocks([
                { canHandle: true, executeTime: 0, toReturn: "" },
                { canHandle: false, executeTime: 0, toReturn: "" },
            ]);
            const result = await mocks.aggregateMockHandler.canHandle("something");
            (0, globals_1.expect)(result).toBe(true);
        });
        (0, globals_1.it)("should error if there is no correct handler", async () => {
            const mocks = initMocks([
                { canHandle: false, executeTime: 0, toReturn: "" },
                { canHandle: false, executeTime: 0, toReturn: "" },
            ]);
            (0, globals_1.expect)(await mocks.aggregateMockHandler.canHandle("something")).toBe(false);
        });
    });
    (0, globals_1.describe)("handle", () => {
        (0, globals_1.it)("should execute the handler", async () => {
            const mocks = initMocks([
                { canHandle: true, executeTime: 0, toReturn: "allGood" },
            ]);
            const result = await mocks.aggregateMockHandler.handle("something");
            (0, globals_1.expect)(result).toBe("allGood");
        });
        globals_1.it.todo("should run the correct handler even when it is preceded by the incorrect handler");
        globals_1.it.todo("should run the first correct handler even when succeeded by a handler that takes a shorter time to execute");
        (0, globals_1.it)("should error when there is no correct handler", async () => {
            const mocks = initMocks([
                { canHandle: false, executeTime: 0, toReturn: "" },
                { canHandle: false, executeTime: 0, toReturn: "" },
            ]);
            await (0, globals_1.expect)(() => mocks.aggregateMockHandler.handle("something")).rejects.toThrow();
        });
        (0, globals_1.it)("should error when there is no correct handler, and handle invalid JSON", async () => {
            const mocks = initMocks([
                { canHandle: false, executeTime: 0, toReturn: "" },
                { canHandle: false, executeTime: 0, toReturn: "" },
            ]);
            const obj = {
                prop: {},
            };
            obj.prop = obj;
            await (0, globals_1.expect)(() => mocks.aggregateMockHandler.handle(obj)).rejects.toThrow();
        });
    });
});
//# sourceMappingURL=AggregateHandler.spec.js.map