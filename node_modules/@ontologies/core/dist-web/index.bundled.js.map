{"version":3,"file":"index.bundled.js","sources":["index.js","../../node_modules/@ungap/global-this/esm/index.js"],"sourcesContent":["import '@ungap/global-this';\n\nvar TermType;\n(function (TermType) {\n    TermType[\"NamedNode\"] = \"NamedNode\";\n    TermType[\"BlankNode\"] = \"BlankNode\";\n    TermType[\"Literal\"] = \"Literal\";\n})(TermType || (TermType = {}));\nvar QuadPosition;\n(function (QuadPosition) {\n    QuadPosition[QuadPosition[\"subject\"] = 0] = \"subject\";\n    QuadPosition[QuadPosition[\"predicate\"] = 1] = \"predicate\";\n    QuadPosition[QuadPosition[\"object\"] = 2] = \"object\";\n    QuadPosition[QuadPosition[\"graph\"] = 3] = \"graph\";\n})(QuadPosition || (QuadPosition = {}));\nvar Feature;\n(function (Feature) {\n    /** Whether the factory supports termType:Collection terms */\n    Feature[\"collections\"] = \"COLLECTIONS\";\n    /** Whether the factory supports termType:DefaultGraph terms */\n    Feature[\"defaultGraphType\"] = \"DEFAULT_GRAPH_TYPE\";\n    /** Whether the factory supports equals on produced instances */\n    Feature[\"equalsMethod\"] = \"EQUALS_METHOD\";\n    /** Whether the factory can create a unique idempotent identifier for the given term. */\n    Feature[\"id\"] = \"ID\";\n    /** Whether the factory stores its unique idempotent identifier for the given term on the instance with the `id` property (implies Feature.id). */\n    Feature[\"idStamp\"] = \"ID_STAMP\";\n    /** Whether the factory will return the same instance for subsequent calls (implies implies Feature.id and `===`). */\n    Feature[\"identity\"] = \"IDENTITY\";\n    /** Whether the factory supports mapping ids back to instances (should adhere to the identity setting) */\n    Feature[\"reversibleId\"] = \"REVERSIBLE_ID\";\n    /** Whether the factory supports termType:Variable terms */\n    Feature[\"variableType\"] = \"VARIABLE_TYPE\";\n})(Feature || (Feature = {}));\n\nconst datatypes = {\n    boolean: \"http://www.w3.org/2001/XMLSchema#boolean\",\n    dateTime: \"http://www.w3.org/2001/XMLSchema#dateTime\",\n    double: \"http://www.w3.org/2001/XMLSchema#double\",\n    decimal: \"http://www.w3.org/2001/XMLSchema#decimal\",\n    integer: \"http://www.w3.org/2001/XMLSchema#integer\",\n    langString: \"http://www.w3.org/1999/02/22-rdf-syntax-ns#langString\",\n    string: \"http://www.w3.org/2001/XMLSchema#string\",\n};\nfunction equals(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (!a || !b) {\n        return a === b;\n    }\n    if (Array.isArray(a) || Array.isArray(b)) {\n        if (!(Array.isArray(a) && Array.isArray(b))) {\n            return false;\n        }\n        return equals(a[0], b[0])\n            && equals(a[1], b[1])\n            && equals(a[2], b[2])\n            && equals(a[3], b[3]);\n    }\n    if (PlainFactory.isQuad(a) || PlainFactory.isQuad(b)) {\n        if (!PlainFactory.isQuad(a) || !PlainFactory.isQuad(b)) {\n            return false;\n        }\n        return equals(a.subject, b.subject)\n            && equals(a.predicate, b.predicate)\n            && equals(a.object, b.object)\n            && equals(a.graph, b.graph);\n    }\n    switch (a.termType) {\n        case 'Literal': {\n            return a.termType === b.termType\n                && a.value === b.value\n                && b.datatype === b.datatype\n                && b.language === b.language;\n        }\n        default:\n            if (!a.termType || !b.termType) {\n                return false;\n            }\n            return a.termType === b.termType\n                && a.value === b.value;\n    }\n}\nconst RDFBase = {\n    equals(other) {\n        return equals(this, other);\n    },\n    /* rdflib compat */\n    toCanonical() {\n        return this;\n    },\n};\n/**\n * Plain JS/functional implementation of the RDF/JS: Data model specification, limited to a strict\n * rdf subset (no Variable, no Literal as predicate, etc.).\n */\nclass PlainFactory {\n    constructor(opts = {}) {\n        this.bnIndex = opts.bnIndex || 0;\n        this.supports = opts.supports || {\n            [Feature.collections]: false,\n            [Feature.defaultGraphType]: false,\n            [Feature.equalsMethod]: false,\n            [Feature.id]: true,\n            [Feature.idStamp]: false,\n            [Feature.identity]: false,\n            [Feature.reversibleId]: true,\n            [Feature.variableType]: false,\n        };\n    }\n    /**\n     * Checks if the object {obj} is a Quad.\n     */\n    static isQuad(obj) {\n        if (Array.isArray(obj) || typeof obj !== \"object\" || obj === null) {\n            return false;\n        }\n        return !!(\"subject\" in obj\n            && \"predicate\" in obj\n            && \"object\" in obj);\n    }\n    namedNode(value) {\n        const term = Object.create(RDFBase);\n        term.termType = TermType.NamedNode;\n        term.value = value;\n        return term;\n    }\n    blankNode(value) {\n        const term = Object.create(RDFBase);\n        term.termType = TermType.BlankNode;\n        term.value = value || `b${++this.bnIndex}`;\n        return term;\n    }\n    literal(value, languageOrDatatype) {\n        if (typeof value !== \"string\") {\n            return this.parseLiteral(value);\n        }\n        const term = Object.create(RDFBase);\n        term.termType = TermType.Literal;\n        // Perf: Always set all properties to prevent the creation of unnecessary HiddenClass objects.\n        term.language = typeof languageOrDatatype === \"string\" ? languageOrDatatype : undefined;\n        term.datatype = typeof languageOrDatatype === \"string\"\n            ? this.namedNode(datatypes.langString)\n            : languageOrDatatype || this.namedNode(datatypes.string);\n        term.value = value;\n        return term;\n    }\n    defaultGraph() {\n        return this.namedNode(\"rdf:defaultGraph\");\n    }\n    /**\n     * Create an RDF statement in object form.\n     * @param subject The subject of the statement\n     * @param predicate The predicate of the statement\n     * @param object The object of the statement\n     * @param graph The graph of the statement\n     */\n    quad(subject, predicate, object, graph) {\n        return {\n            subject,\n            predicate,\n            object,\n            graph: graph || this.defaultGraph()\n        };\n    }\n    isQuad(obj) {\n        return PlainFactory.isQuad(obj);\n    }\n    /**\n     * * Returns an RDF statement in array form.\n     * @param subject The subject of the statement\n     * @param predicate The predicate of the statement\n     * @param object The object of the statement\n     * @param graph The graph of the statement\n     */\n    quadruple(subject, predicate, object, graph) {\n        return [\n            subject,\n            predicate,\n            object,\n            graph || this.defaultGraph(),\n        ];\n    }\n    fromTerm(original) {\n        if (original.termType === \"Literal\") {\n            return this.literal(original.value, original.language || original.datatype);\n        }\n        return {\n            termType: original.termType,\n            value: original.value,\n        };\n    }\n    fromQuad(original) {\n        return {\n            subject: original.subject,\n            predicate: original.predicate,\n            object: original.object,\n            graph: original.graph || this.defaultGraph(),\n        };\n    }\n    fromQdr(original) {\n        return {\n            subject: original[0],\n            predicate: original[1],\n            object: original[2],\n            graph: original[3] || this.defaultGraph(),\n        };\n    }\n    qdrFromQuad(original) {\n        return [\n            original.subject,\n            original.predicate,\n            original.object,\n            original.graph || this.defaultGraph(),\n        ];\n    }\n    qdrFromQdr(original) {\n        return [\n            original[0],\n            original[1],\n            original[2],\n            original[3] || this.defaultGraph(),\n        ];\n    }\n    /**\n     * Compare if two RDF objects are the same.\n     *\n     * Should work with non-standard rdf libraries as well (e.g. supporting Variable and Collection).\n     */\n    equals(a, b) {\n        return equals(a, b);\n    }\n    fromId(id) {\n        return this.termFromNQ(id);\n    }\n    id(obj) {\n        return this.toNQ(obj);\n    }\n    termFromNQ(nq) {\n        if (nq.startsWith(\"<\")) {\n            return this.namedNode(nq.slice(\"<\".length, -1));\n        }\n        else if (nq.startsWith(\"_\")) {\n            return this.blankNode(nq.slice(\"_:\".length, -1));\n        }\n        else if (nq.startsWith('\"')) {\n            const [valueOrLang, datatype] = nq.split(\"^^\");\n            const [value, lang] = valueOrLang.split(\"@\");\n            return this.literal(value.slice(1, -1), lang || (datatype ? this.namedNode(datatype) : undefined));\n        }\n        else {\n            throw new Error(\"Unknown term given\");\n        }\n    }\n    toNQ(term) {\n        if (Array.isArray(term)) {\n            const graph = term[3] === this.defaultGraph() ? '' : (this.toNQ(term[3]) + ' ');\n            return `${this.toNQ(term[0])} ${this.toNQ(term[1])} ${this.toNQ(term[2])} ${graph}.`;\n        }\n        else if (this.isQuad(term)) {\n            return this.quadToNQ(term);\n        }\n        return this.termToNQ(term);\n    }\n    parseLiteral(value) {\n        let literalValue = undefined;\n        let datatype = undefined;\n        if (typeof value === \"number\" || value instanceof Number) {\n            // From rdflib; https://github.com/linkeddata/rdflib.js/blob/master/src/literal.js#L104\n            if (value.toString().indexOf('e') < 0 && Math.ceil(value) <= Number.MAX_SAFE_INTEGER) {\n                datatype = Number.isInteger(value) ? datatypes.integer : datatypes.decimal;\n            }\n            else {\n                datatype = datatypes.double;\n            }\n            literalValue = value.toString();\n        }\n        else if (typeof value === \"boolean\" || value instanceof Boolean) {\n            literalValue = value.toString();\n            datatype = datatypes.boolean;\n        }\n        else if (typeof value === \"bigint\") {\n            datatype = datatypes.integer;\n            literalValue = value.toString();\n        }\n        else if (typeof value === \"object\") {\n            if (value instanceof Date) {\n                if (isNaN(value.getTime())) {\n                    throw new Error('Invalid date given');\n                }\n                literalValue = value.toISOString();\n                datatype = datatypes.dateTime;\n            }\n        }\n        if (typeof datatype !== \"undefined\") {\n            return this.literal(literalValue, this.namedNode(datatype));\n        }\n        throw new Error(`Can't parse value '${value}'`);\n    }\n    termToNQ(term) {\n        switch (term.termType) {\n            case TermType.BlankNode:\n                return `_:${term.value}`;\n            case TermType.NamedNode:\n                return `<${term.value}>`;\n            case TermType.Literal:\n                const escaped = `\"${term.value.replace(/([\\n\"\\\\\\r])/g, (match) => {\n                    switch (match) {\n                        case \"\\n\": return \"\\\\n\";\n                        case \"\\r\": return \"\\\\r\";\n                        case \"\\\"\": return \"\\\\\\\"\";\n                        case \"\\\\\": return \"\\\\\\\\\";\n                        default: return match;\n                    }\n                })}\"`;\n                if (term.datatype) {\n                    if (term.datatype.value === datatypes.string) {\n                        return escaped;\n                    }\n                    return `${escaped}^^${this.termToNQ(term.datatype)}`;\n                }\n                if (term.language) {\n                    return `${escaped}@${term.language}`;\n                }\n                return escaped;\n            default:\n                throw new Error(`Nonstandard termtype '${term.termType}' given`);\n        }\n    }\n    quadrupleToNQ(quad) {\n        const graph = !quad[QuadPosition.graph] || quad[QuadPosition.graph] === this.defaultGraph()\n            ? ''\n            : (this.toNQ(quad[QuadPosition.graph]) + ' ');\n        return `${this.toNQ(quad[QuadPosition.subject])} ${this.toNQ(quad[QuadPosition.predicate])} ${this.toNQ(quad[QuadPosition.object])} ${graph}.\\n`;\n    }\n    quadToNQ(quad) {\n        return this.quadrupleToNQ([\n            quad.subject,\n            quad.predicate,\n            quad.object,\n            quad.graph || this.defaultGraph(),\n        ]);\n    }\n}\n/**\n * Plain JS/functional implementation of the RDF/JS: Data model specification, limited to a strict\n * rdf subset (no Variable, no Literal as predicate, etc.).\n */\nconst DefaultFactory = new PlainFactory();\n\nfunction isTerm(obj) {\n    return typeof obj === \"object\" && obj !== null && \"termType\" in obj;\n}\nfunction isNamedNode(obj) {\n    return isTerm(obj) && obj.termType === TermType.NamedNode;\n}\nfunction isBlankNode(obj) {\n    return isTerm(obj) && obj.termType === TermType.BlankNode;\n}\nfunction isLiteral(obj) {\n    return isTerm(obj) && obj.termType === TermType.Literal;\n}\nconst TermTypes = [\n    TermType.NamedNode.toString(),\n    TermType.BlankNode.toString(),\n    TermType.Literal.toString()\n];\nfunction isSomeTerm(obj) {\n    return isTerm(obj) && TermTypes.includes(obj.termType) === true;\n}\nconst NodeTypes = [TermType.NamedNode.toString(), TermType.BlankNode.toString()];\nfunction isNode(obj) {\n    return isTerm(obj) && NodeTypes.includes(obj.termType) === true;\n}\nfunction isQuad(obj) {\n    return typeof obj === \"object\" && obj !== null && \"subject\" in obj;\n}\nfunction doc(node) {\n    if (node.value.indexOf('#') < 0) {\n        return node.value;\n    }\n    else {\n        return node.value.split('#')[0];\n    }\n}\n\nlet setup;\nlet globalFactory;\nlet globalSymbol;\nfunction shouldOverride(rdfFactory, override) {\n    const factory = globalThis[rdfFactory];\n    return typeof factory === \"undefined\" || factory === DefaultFactory || override;\n}\nfunction changeFactory(rdfFactory, factory, override) {\n    if (shouldOverride(rdfFactory, override)) {\n        globalThis[rdfFactory] = factory;\n        globalFactory = factory;\n    }\n    else if (typeof globalFactory === \"undefined\" || override) {\n        globalThis[rdfFactory] = factory;\n        globalFactory = factory;\n    }\n}\nif (typeof Symbol !== \"undefined\") {\n    const rdfFactory = Symbol.for('rdfFactory');\n    setup = function setup(factory = DefaultFactory, override = true) {\n        changeFactory(rdfFactory, factory, override);\n        globalFactory = globalThis[rdfFactory];\n    };\n    globalSymbol = rdfFactory;\n}\nelse {\n    const rdfFactory = 'rdfFactory';\n    setup = function setup(factory = DefaultFactory, override = true) {\n        changeFactory(rdfFactory, factory, override);\n    };\n    globalSymbol = rdfFactory;\n    globalFactory = globalThis[rdfFactory];\n}\nsetup(DefaultFactory);\nconst createNS = (ns) => (term) => globalFactory.namedNode(`${ns}${term}`);\nlet proxy;\nif (typeof Proxy !== \"undefined\") {\n    proxy = new Proxy(globalFactory || {}, {\n        ownKeys() {\n            return globalFactory && Object.keys(globalFactory) || [];\n        },\n        getOwnPropertyDescriptor(_, k) {\n            return Object.getOwnPropertyDescriptor(globalFactory, k);\n        },\n        set(_, property, value) {\n            globalFactory[property] = value;\n            return true;\n        },\n        get(_, property) {\n            return globalFactory[property];\n        },\n    });\n}\nelse {\n    proxy = [\n        'namedNode',\n        'blankNode',\n        'literal',\n        'defaultGraph',\n        'quad',\n        'quadruple',\n        'fromTerm',\n        'fromQuad',\n        'fromQdr',\n        'qdrFromQuad',\n        'qdrFromQdr',\n        'equals',\n        'id',\n        'toNQ',\n        'fromId',\n        'termToNQ',\n        'termFromNQ',\n        'quadrupleToNQ',\n        'quadToNQ',\n        'supports',\n    ].reduce((acc, key) => {\n        acc[key] = (...args) => globalFactory[key](...args);\n        return acc;\n    }, {});\n}\nvar proxy$1 = proxy;\n\nexport default proxy$1;\nexport { Feature, PlainFactory, QuadPosition, TermType, createNS, doc, globalFactory, globalSymbol, isBlankNode, isLiteral, isNamedNode, isNode, isQuad, isSomeTerm, isTerm, setup };\n//# sourceMappingURL=index.js.map\n","(function (Object) {\n  typeof globalThis !== 'object' && (\n    this ?\n      get() :\n      (Object.defineProperty(Object.prototype, '_T_', {\n        configurable: true,\n        get: get\n      }), _T_)\n  );\n  function get() {\n    this.globalThis = this;\n    delete Object.prototype._T_;\n  }\n}(Object));\nexport default globalThis;\n"],"names":["TermType","QuadPosition","Feature","Object","get","globalThis","this","prototype","_T_","defineProperty","configurable"],"mappings":"IAAWA,EAMAC,EAOAC,GCbV,SAAUC,YASAC,SACFC,WAAaC,YACXH,EAAOI,UAAUC,IAVJ,iBAAfH,aACLC,KACEF,KACCD,EAAOM,eAAeN,EAAOI,UAAW,MAAO,CAC9CG,cAAc,EACdN,IAAKA,IACHI,MAPT,CAaCL,QDZF,SAAWH,GACPA,EAAQ,UAAgB,YACxBA,EAAQ,UAAgB,YACxBA,EAAQ,QAAc,UAH1B,CAIGA,IAAaA,EAAW,KAE3B,SAAWC,GACPA,EAAaA,EAAY,QAAc,GAAK,UAC5CA,EAAaA,EAAY,UAAgB,GAAK,YAC9CA,EAAaA,EAAY,OAAa,GAAK,SAC3CA,EAAaA,EAAY,MAAY,GAAK,QAJ9C,CAKGA,IAAiBA,EAAe,KAEnC,SAAWC,GAEPA,EAAO,YAAkB,cAEzBA,EAAO,iBAAuB,qBAE9BA,EAAO,aAAmB,gBAE1BA,EAAO,GAAS,KAEhBA,EAAO,QAAc,WAErBA,EAAO,SAAe,WAEtBA,EAAO,aAAmB,gBAE1BA,EAAO,aAAmB,gBAhB9B,CAiBGA,IAAYA,EAAU"}