import { Feature, QuadPosition, TermType, } from "./types";
const datatypes = {
    boolean: "http://www.w3.org/2001/XMLSchema#boolean",
    dateTime: "http://www.w3.org/2001/XMLSchema#dateTime",
    double: "http://www.w3.org/2001/XMLSchema#double",
    decimal: "http://www.w3.org/2001/XMLSchema#decimal",
    integer: "http://www.w3.org/2001/XMLSchema#integer",
    langString: "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString",
    string: "http://www.w3.org/2001/XMLSchema#string",
};
function equals(a, b) {
    if (a === b) {
        return true;
    }
    if (!a || !b) {
        return a === b;
    }
    if (Array.isArray(a) || Array.isArray(b)) {
        if (!(Array.isArray(a) && Array.isArray(b))) {
            return false;
        }
        return equals(a[0], b[0])
            && equals(a[1], b[1])
            && equals(a[2], b[2])
            && equals(a[3], b[3]);
    }
    if (PlainFactory.isQuad(a) || PlainFactory.isQuad(b)) {
        if (!PlainFactory.isQuad(a) || !PlainFactory.isQuad(b)) {
            return false;
        }
        return equals(a.subject, b.subject)
            && equals(a.predicate, b.predicate)
            && equals(a.object, b.object)
            && equals(a.graph, b.graph);
    }
    switch (a.termType) {
        case 'Literal': {
            return a.termType === b.termType
                && a.value === b.value
                && b.datatype === b.datatype
                && b.language === b.language;
        }
        default:
            if (!a.termType || !b.termType) {
                return false;
            }
            return a.termType === b.termType
                && a.value === b.value;
    }
}
const RDFBase = {
    equals(other) {
        return equals(this, other);
    },
    /* rdflib compat */
    toCanonical() {
        return this;
    },
};
/**
 * Plain JS/functional implementation of the RDF/JS: Data model specification, limited to a strict
 * rdf subset (no Variable, no Literal as predicate, etc.).
 */
export class PlainFactory {
    constructor(opts = {}) {
        this.bnIndex = opts.bnIndex || 0;
        this.supports = opts.supports || {
            [Feature.collections]: false,
            [Feature.defaultGraphType]: false,
            [Feature.equalsMethod]: false,
            [Feature.id]: true,
            [Feature.idStamp]: false,
            [Feature.identity]: false,
            [Feature.reversibleId]: true,
            [Feature.variableType]: false,
        };
    }
    /**
     * Checks if the object {obj} is a Quad.
     */
    static isQuad(obj) {
        if (Array.isArray(obj) || typeof obj !== "object" || obj === null) {
            return false;
        }
        return !!("subject" in obj
            && "predicate" in obj
            && "object" in obj);
    }
    namedNode(value) {
        const term = Object.create(RDFBase);
        term.termType = TermType.NamedNode;
        term.value = value;
        return term;
    }
    blankNode(value) {
        const term = Object.create(RDFBase);
        term.termType = TermType.BlankNode;
        term.value = value || `b${++this.bnIndex}`;
        return term;
    }
    literal(value, languageOrDatatype) {
        if (typeof value !== "string") {
            return this.parseLiteral(value);
        }
        const term = Object.create(RDFBase);
        term.termType = TermType.Literal;
        // Perf: Always set all properties to prevent the creation of unnecessary HiddenClass objects.
        term.language = typeof languageOrDatatype === "string" ? languageOrDatatype : undefined;
        term.datatype = typeof languageOrDatatype === "string"
            ? this.namedNode(datatypes.langString)
            : languageOrDatatype || this.namedNode(datatypes.string);
        term.value = value;
        return term;
    }
    defaultGraph() {
        return this.namedNode("rdf:defaultGraph");
    }
    /**
     * Create an RDF statement in object form.
     * @param subject The subject of the statement
     * @param predicate The predicate of the statement
     * @param object The object of the statement
     * @param graph The graph of the statement
     */
    quad(subject, predicate, object, graph) {
        return {
            subject,
            predicate,
            object,
            graph: graph || this.defaultGraph()
        };
    }
    isQuad(obj) {
        return PlainFactory.isQuad(obj);
    }
    /**
     * * Returns an RDF statement in array form.
     * @param subject The subject of the statement
     * @param predicate The predicate of the statement
     * @param object The object of the statement
     * @param graph The graph of the statement
     */
    quadruple(subject, predicate, object, graph) {
        return [
            subject,
            predicate,
            object,
            graph || this.defaultGraph(),
        ];
    }
    fromTerm(original) {
        if (original.termType === "Literal") {
            return this.literal(original.value, original.language || original.datatype);
        }
        return {
            termType: original.termType,
            value: original.value,
        };
    }
    fromQuad(original) {
        return {
            subject: original.subject,
            predicate: original.predicate,
            object: original.object,
            graph: original.graph || this.defaultGraph(),
        };
    }
    fromQdr(original) {
        return {
            subject: original[0],
            predicate: original[1],
            object: original[2],
            graph: original[3] || this.defaultGraph(),
        };
    }
    qdrFromQuad(original) {
        return [
            original.subject,
            original.predicate,
            original.object,
            original.graph || this.defaultGraph(),
        ];
    }
    qdrFromQdr(original) {
        return [
            original[0],
            original[1],
            original[2],
            original[3] || this.defaultGraph(),
        ];
    }
    /**
     * Compare if two RDF objects are the same.
     *
     * Should work with non-standard rdf libraries as well (e.g. supporting Variable and Collection).
     */
    equals(a, b) {
        return equals(a, b);
    }
    fromId(id) {
        return this.termFromNQ(id);
    }
    id(obj) {
        return this.toNQ(obj);
    }
    termFromNQ(nq) {
        if (nq.startsWith("<")) {
            return this.namedNode(nq.slice("<".length, -1));
        }
        else if (nq.startsWith("_")) {
            return this.blankNode(nq.slice("_:".length, -1));
        }
        else if (nq.startsWith('"')) {
            const [valueOrLang, datatype] = nq.split("^^");
            const [value, lang] = valueOrLang.split("@");
            return this.literal(value.slice(1, -1), lang || (datatype ? this.namedNode(datatype) : undefined));
        }
        else {
            throw new Error("Unknown term given");
        }
    }
    toNQ(term) {
        if (Array.isArray(term)) {
            const graph = term[3] === this.defaultGraph() ? '' : (this.toNQ(term[3]) + ' ');
            return `${this.toNQ(term[0])} ${this.toNQ(term[1])} ${this.toNQ(term[2])} ${graph}.`;
        }
        else if (this.isQuad(term)) {
            return this.quadToNQ(term);
        }
        return this.termToNQ(term);
    }
    parseLiteral(value) {
        let literalValue = undefined;
        let datatype = undefined;
        if (typeof value === "number" || value instanceof Number) {
            // From rdflib; https://github.com/linkeddata/rdflib.js/blob/master/src/literal.js#L104
            if (value.toString().indexOf('e') < 0 && Math.ceil(value) <= Number.MAX_SAFE_INTEGER) {
                datatype = Number.isInteger(value) ? datatypes.integer : datatypes.decimal;
            }
            else {
                datatype = datatypes.double;
            }
            literalValue = value.toString();
        }
        else if (typeof value === "boolean" || value instanceof Boolean) {
            literalValue = value.toString();
            datatype = datatypes.boolean;
        }
        else if (typeof value === "bigint") {
            datatype = datatypes.integer;
            literalValue = value.toString();
        }
        else if (typeof value === "object") {
            if (value instanceof Date) {
                if (isNaN(value.getTime())) {
                    throw new Error('Invalid date given');
                }
                literalValue = value.toISOString();
                datatype = datatypes.dateTime;
            }
        }
        if (typeof datatype !== "undefined") {
            return this.literal(literalValue, this.namedNode(datatype));
        }
        throw new Error(`Can't parse value '${value}'`);
    }
    termToNQ(term) {
        switch (term.termType) {
            case TermType.BlankNode:
                return `_:${term.value}`;
            case TermType.NamedNode:
                return `<${term.value}>`;
            case TermType.Literal:
                const escaped = `"${term.value.replace(/([\n"\\\r])/g, (match) => {
                    switch (match) {
                        case "\n": return "\\n";
                        case "\r": return "\\r";
                        case "\"": return "\\\"";
                        case "\\": return "\\\\";
                        default: return match;
                    }
                })}"`;
                if (term.datatype) {
                    if (term.datatype.value === datatypes.string) {
                        return escaped;
                    }
                    return `${escaped}^^${this.termToNQ(term.datatype)}`;
                }
                if (term.language) {
                    return `${escaped}@${term.language}`;
                }
                return escaped;
            default:
                throw new Error(`Nonstandard termtype '${term.termType}' given`);
        }
    }
    quadrupleToNQ(quad) {
        const graph = !quad[QuadPosition.graph] || quad[QuadPosition.graph] === this.defaultGraph()
            ? ''
            : (this.toNQ(quad[QuadPosition.graph]) + ' ');
        return `${this.toNQ(quad[QuadPosition.subject])} ${this.toNQ(quad[QuadPosition.predicate])} ${this.toNQ(quad[QuadPosition.object])} ${graph}.\n`;
    }
    quadToNQ(quad) {
        return this.quadrupleToNQ([
            quad.subject,
            quad.predicate,
            quad.object,
            quad.graph || this.defaultGraph(),
        ]);
    }
}
/**
 * Plain JS/functional implementation of the RDF/JS: Data model specification, limited to a strict
 * rdf subset (no Variable, no Literal as predicate, etc.).
 */
export const DefaultFactory = new PlainFactory();
