{"id":"node_modules/@inrupt/solid-client-authn-core/dist/authenticatedFetch/fetchFactory.js","dependencies":[{"name":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-core/dist/authenticatedFetch/fetchFactory.js.map","includedInParent":true,"mtime":1652099631133},{"name":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-core/src/authenticatedFetch/fetchFactory.ts","includedInParent":true,"mtime":1652099631190},{"name":"/Users/tdrave/demo-solid-app/package.json","includedInParent":true,"mtime":1652099771977},{"name":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-core/package.json","includedInParent":true,"mtime":1652099631124},{"name":"cross-fetch","loc":{"line":4,"column":30,"index":191},"parent":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-core/dist/authenticatedFetch/fetchFactory.js","resolved":"/Users/tdrave/demo-solid-app/node_modules/cross-fetch/dist/browser-ponyfill.js"},{"name":"../constant","loc":{"line":5,"column":27,"index":234},"parent":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-core/dist/authenticatedFetch/fetchFactory.js","resolved":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-core/dist/constant.js"},{"name":"./dpopUtils","loc":{"line":6,"column":28,"index":278},"parent":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-core/dist/authenticatedFetch/fetchFactory.js","resolved":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-core/dist/authenticatedFetch/dpopUtils.js"},{"name":"../errors/OidcProviderError","loc":{"line":7,"column":36,"index":330},"parent":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-core/dist/authenticatedFetch/fetchFactory.js","resolved":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-core/dist/errors/OidcProviderError.js"},{"name":"../errors/InvalidResponseError","loc":{"line":8,"column":39,"index":401},"parent":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-core/dist/authenticatedFetch/fetchFactory.js","resolved":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-core/dist/errors/InvalidResponseError.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.buildAuthenticatedFetch = exports.DEFAULT_EXPIRATION_TIME_SECONDS = void 0;\nconst cross_fetch_1 = require(\"cross-fetch\");\nconst constant_1 = require(\"../constant\");\nconst dpopUtils_1 = require(\"./dpopUtils\");\nconst OidcProviderError_1 = require(\"../errors/OidcProviderError\");\nconst InvalidResponseError_1 = require(\"../errors/InvalidResponseError\");\nexports.DEFAULT_EXPIRATION_TIME_SECONDS = 600;\nfunction isExpectedAuthError(statusCode) {\n    return [401, 403].includes(statusCode);\n}\nasync function buildDpopFetchOptions(targetUrl, authToken, dpopKey, defaultOptions) {\n    var _a;\n    const headers = new cross_fetch_1.Headers(defaultOptions === null || defaultOptions === void 0 ? void 0 : defaultOptions.headers);\n    headers.set(\"Authorization\", `DPoP ${authToken}`);\n    headers.set(\"DPoP\", await (0, dpopUtils_1.createDpopHeader)(targetUrl, (_a = defaultOptions === null || defaultOptions === void 0 ? void 0 : defaultOptions.method) !== null && _a !== void 0 ? _a : \"get\", dpopKey));\n    return {\n        ...defaultOptions,\n        headers,\n    };\n}\nasync function buildAuthenticatedHeaders(targetUrl, authToken, dpopKey, defaultOptions) {\n    if (dpopKey !== undefined) {\n        return buildDpopFetchOptions(targetUrl, authToken, dpopKey, defaultOptions);\n    }\n    const headers = new cross_fetch_1.Headers(defaultOptions === null || defaultOptions === void 0 ? void 0 : defaultOptions.headers);\n    headers.set(\"Authorization\", `Bearer ${authToken}`);\n    return {\n        ...defaultOptions,\n        headers,\n    };\n}\nasync function makeAuthenticatedRequest(unauthFetch, accessToken, url, defaultRequestInit, dpopKey) {\n    return unauthFetch(url, await buildAuthenticatedHeaders(url.toString(), accessToken, dpopKey, defaultRequestInit));\n}\nasync function refreshAccessToken(refreshOptions, dpopKey, eventEmitter) {\n    var _a;\n    const tokenSet = await refreshOptions.tokenRefresher.refresh(refreshOptions.sessionId, refreshOptions.refreshToken, dpopKey);\n    eventEmitter === null || eventEmitter === void 0 ? void 0 : eventEmitter.emit(constant_1.EVENTS.SESSION_EXTENDED, (_a = tokenSet.expiresIn) !== null && _a !== void 0 ? _a : exports.DEFAULT_EXPIRATION_TIME_SECONDS);\n    if (typeof tokenSet.refreshToken === \"string\") {\n        eventEmitter === null || eventEmitter === void 0 ? void 0 : eventEmitter.emit(constant_1.EVENTS.NEW_REFRESH_TOKEN, tokenSet.refreshToken);\n    }\n    return {\n        accessToken: tokenSet.accessToken,\n        refreshToken: tokenSet.refreshToken,\n        expiresIn: tokenSet.expiresIn,\n    };\n}\nconst computeRefreshDelay = (expiresIn) => {\n    if (expiresIn !== undefined) {\n        return expiresIn - constant_1.REFRESH_BEFORE_EXPIRATION_SECONDS > 0\n            ?\n                expiresIn - constant_1.REFRESH_BEFORE_EXPIRATION_SECONDS\n            : expiresIn;\n    }\n    return exports.DEFAULT_EXPIRATION_TIME_SECONDS;\n};\nasync function buildAuthenticatedFetch(unauthFetch, accessToken, options) {\n    var _a;\n    let currentAccessToken = accessToken;\n    let latestTimeout;\n    const currentRefreshOptions = options === null || options === void 0 ? void 0 : options.refreshOptions;\n    if (currentRefreshOptions !== undefined) {\n        const proactivelyRefreshToken = async () => {\n            var _a, _b, _c, _d;\n            try {\n                const { accessToken: refreshedAccessToken, refreshToken, expiresIn, } = await refreshAccessToken(currentRefreshOptions, options.dpopKey, options.eventEmitter);\n                currentAccessToken = refreshedAccessToken;\n                if (refreshToken !== undefined) {\n                    currentRefreshOptions.refreshToken = refreshToken;\n                }\n                clearTimeout(latestTimeout);\n                latestTimeout = setTimeout(proactivelyRefreshToken, computeRefreshDelay(expiresIn) * 1000);\n                (_a = options.eventEmitter) === null || _a === void 0 ? void 0 : _a.emit(constant_1.EVENTS.TIMEOUT_SET, latestTimeout);\n            }\n            catch (e) {\n                if (e instanceof OidcProviderError_1.OidcProviderError) {\n                    (_b = options === null || options === void 0 ? void 0 : options.eventEmitter) === null || _b === void 0 ? void 0 : _b.emit(constant_1.EVENTS.ERROR, e.error, e.errorDescription);\n                    (_c = options === null || options === void 0 ? void 0 : options.eventEmitter) === null || _c === void 0 ? void 0 : _c.emit(constant_1.EVENTS.SESSION_EXPIRED);\n                }\n                if (e instanceof InvalidResponseError_1.InvalidResponseError &&\n                    e.missingFields.includes(\"access_token\")) {\n                    (_d = options === null || options === void 0 ? void 0 : options.eventEmitter) === null || _d === void 0 ? void 0 : _d.emit(constant_1.EVENTS.SESSION_EXPIRED);\n                }\n            }\n        };\n        latestTimeout = setTimeout(proactivelyRefreshToken, computeRefreshDelay(options.expiresIn) * 1000);\n        (_a = options.eventEmitter) === null || _a === void 0 ? void 0 : _a.emit(constant_1.EVENTS.TIMEOUT_SET, latestTimeout);\n    }\n    else if (options !== undefined && options.eventEmitter !== undefined) {\n        const expirationTimeout = setTimeout(() => {\n            options.eventEmitter.emit(constant_1.EVENTS.SESSION_EXPIRED);\n        }, computeRefreshDelay(options.expiresIn) * 1000);\n        options.eventEmitter.emit(constant_1.EVENTS.TIMEOUT_SET, expirationTimeout);\n    }\n    return async (url, requestInit) => {\n        let response = await makeAuthenticatedRequest(unauthFetch, currentAccessToken, url, requestInit, options === null || options === void 0 ? void 0 : options.dpopKey);\n        const failedButNotExpectedAuthError = !response.ok && !isExpectedAuthError(response.status);\n        if (response.ok || failedButNotExpectedAuthError) {\n            return response;\n        }\n        const hasBeenRedirected = response.url !== url;\n        if (hasBeenRedirected && (options === null || options === void 0 ? void 0 : options.dpopKey) !== undefined) {\n            response = await makeAuthenticatedRequest(unauthFetch, currentAccessToken, response.url, requestInit, options.dpopKey);\n        }\n        return response;\n    };\n}\nexports.buildAuthenticatedFetch = buildAuthenticatedFetch;\n"},"sourceMaps":{"js":{"version":3,"file":"fetchFactory.js","sourceRoot":"","sources":["../../src/authenticatedFetch/fetchFactory.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2022 Inrupt Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n * Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n// eslint-disable-next-line no-shadow\nimport { fetch, Headers } from \"cross-fetch\";\nimport { EventEmitter } from \"events\";\nimport { REFRESH_BEFORE_EXPIRATION_SECONDS, EVENTS } from \"../constant\";\nimport { ITokenRefresher } from \"../login/oidc/refresh/ITokenRefresher\";\nimport { createDpopHeader, KeyPair } from \"./dpopUtils\";\nimport { OidcProviderError } from \"../errors/OidcProviderError\";\nimport { InvalidResponseError } from \"../errors/InvalidResponseError\";\n\nexport type RefreshOptions = {\n  sessionId: string;\n  refreshToken: string;\n  tokenRefresher: ITokenRefresher;\n};\n\n/**\n * If expires_in isn't specified for the access token, we assume its lifetime is\n * 10 minutes.\n */\nexport const DEFAULT_EXPIRATION_TIME_SECONDS = 600;\n\nfunction isExpectedAuthError(statusCode: number): boolean {\n  // As per https://tools.ietf.org/html/rfc7235#section-3.1 and https://tools.ietf.org/html/rfc7235#section-3.1,\n  // a response failing because the provided credentials aren't accepted by the\n  // server can get a 401 or a 403 response.\n  return [401, 403].includes(statusCode);\n}\n\nexport type DpopHeaderPayload = {\n  htu: string;\n  htm: string;\n  jti: string;\n};\n\nasync function buildDpopFetchOptions(\n  targetUrl: string,\n  authToken: string,\n  dpopKey: KeyPair,\n  defaultOptions?: RequestInit\n): Promise<RequestInit> {\n  const headers = new Headers(defaultOptions?.headers);\n  // Any pre-existing Authorization header should be overriden.\n  headers.set(\"Authorization\", `DPoP ${authToken}`);\n  headers.set(\n    \"DPoP\",\n    await createDpopHeader(targetUrl, defaultOptions?.method ?? \"get\", dpopKey)\n  );\n  return {\n    ...defaultOptions,\n    headers,\n  };\n}\n\nasync function buildAuthenticatedHeaders(\n  targetUrl: string,\n  authToken: string,\n  dpopKey?: KeyPair,\n  defaultOptions?: RequestInit\n): Promise<RequestInit> {\n  if (dpopKey !== undefined) {\n    return buildDpopFetchOptions(targetUrl, authToken, dpopKey, defaultOptions);\n  }\n  const headers = new Headers(defaultOptions?.headers);\n  // Any pre-existing Authorization header should be overriden.\n  headers.set(\"Authorization\", `Bearer ${authToken}`);\n  return {\n    ...defaultOptions,\n    headers,\n  };\n}\n\nasync function makeAuthenticatedRequest(\n  unauthFetch: typeof fetch,\n  accessToken: string,\n  url: RequestInfo,\n  defaultRequestInit?: RequestInit,\n  dpopKey?: KeyPair\n) {\n  return unauthFetch(\n    url,\n    await buildAuthenticatedHeaders(\n      url.toString(),\n      accessToken,\n      dpopKey,\n      defaultRequestInit\n    )\n  );\n}\n\nasync function refreshAccessToken(\n  refreshOptions: RefreshOptions,\n  dpopKey?: KeyPair,\n  eventEmitter?: EventEmitter\n): Promise<{ accessToken: string; refreshToken?: string; expiresIn?: number }> {\n  const tokenSet = await refreshOptions.tokenRefresher.refresh(\n    refreshOptions.sessionId,\n    refreshOptions.refreshToken,\n    dpopKey\n  );\n  eventEmitter?.emit(\n    EVENTS.SESSION_EXTENDED,\n    tokenSet.expiresIn ?? DEFAULT_EXPIRATION_TIME_SECONDS\n  );\n  if (typeof tokenSet.refreshToken === \"string\") {\n    eventEmitter?.emit(EVENTS.NEW_REFRESH_TOKEN, tokenSet.refreshToken);\n  }\n  return {\n    accessToken: tokenSet.accessToken,\n    refreshToken: tokenSet.refreshToken,\n    expiresIn: tokenSet.expiresIn,\n  };\n}\n\n/**\n *\n * @param expiresIn Delay until the access token expires.\n * @returns a delay until the access token should be refreshed.\n */\nconst computeRefreshDelay = (expiresIn?: number): number => {\n  if (expiresIn !== undefined) {\n    return expiresIn - REFRESH_BEFORE_EXPIRATION_SECONDS > 0\n      ? // We want to refresh the token 5 seconds before they actually expire.\n        expiresIn - REFRESH_BEFORE_EXPIRATION_SECONDS\n      : expiresIn;\n  }\n  return DEFAULT_EXPIRATION_TIME_SECONDS;\n};\n\n/**\n * @param unauthFetch a regular fetch function, compliant with the WHATWG spec.\n * @param authToken an access token, either a Bearer token or a DPoP one.\n * @param options The option object may contain two objects: the DPoP key token\n * is bound to if applicable, and options to customise token renewal behaviour.\n *\n * @returns A fetch function that adds an appropriate Authorization header with\n * the provided token, and adds a DPoP header if applicable.\n */\nexport async function buildAuthenticatedFetch(\n  unauthFetch: typeof fetch,\n  accessToken: string,\n  options?: {\n    dpopKey?: KeyPair;\n    refreshOptions?: RefreshOptions;\n    expiresIn?: number;\n    eventEmitter?: EventEmitter;\n  }\n): Promise<typeof fetch> {\n  let currentAccessToken = accessToken;\n  let latestTimeout: Parameters<typeof clearTimeout>[0];\n  const currentRefreshOptions: RefreshOptions | undefined =\n    options?.refreshOptions;\n  // Setup the refresh timeout outside of the authenticated fetch, so that\n  // an idle app will not get logged out if it doesn't issue a fetch before\n  // the first expiration date.\n  if (currentRefreshOptions !== undefined) {\n    const proactivelyRefreshToken = async () => {\n      try {\n        const {\n          accessToken: refreshedAccessToken,\n          refreshToken,\n          expiresIn,\n        } = await refreshAccessToken(\n          currentRefreshOptions,\n          // If currentRefreshOptions is defined, options is necessarily defined too.\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          options!.dpopKey,\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          options!.eventEmitter\n        );\n        // Update the tokens in the closure if appropriate.\n        currentAccessToken = refreshedAccessToken;\n        if (refreshToken !== undefined) {\n          currentRefreshOptions.refreshToken = refreshToken;\n        }\n        // Each time the access token is refreshed, we must plan fo the next\n        // refresh iteration.\n        clearTimeout(latestTimeout);\n        latestTimeout = setTimeout(\n          proactivelyRefreshToken,\n          computeRefreshDelay(expiresIn) * 1000\n        );\n        // If currentRefreshOptions is defined, options is necessarily defined too.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        options!.eventEmitter?.emit(EVENTS.TIMEOUT_SET, latestTimeout);\n      } catch (e) {\n        // It is possible that an underlying library throws an error on refresh flow failure.\n        // If we used a log framework, the error could be logged at the `debug` level,\n        // but otherwise the failure of the refresh flow should not blow up in the user's\n        // face, so we just swallow the error.\n        if (e instanceof OidcProviderError) {\n          // The OIDC provider refused to refresh the access token and returned an error instead.\n          /* istanbul ignore next 100% coverage would require testing that nothing\n              happens here if the emitter is undefined, which is more cumbersome\n              than what it's worth. */\n          options?.eventEmitter?.emit(\n            EVENTS.ERROR,\n            e.error,\n            e.errorDescription\n          );\n          /* istanbul ignore next 100% coverage would require testing that nothing\n            happens here if the emitter is undefined, which is more cumbersome\n            than what it's worth. */\n          options?.eventEmitter?.emit(EVENTS.SESSION_EXPIRED);\n        }\n        if (\n          e instanceof InvalidResponseError &&\n          e.missingFields.includes(\"access_token\")\n        ) {\n          // In this case, the OIDC provider returned a non-standard response, but\n          // did not specify that it was an error. We cannot refresh nonetheless.\n          /* istanbul ignore next 100% coverage would require testing that nothing\n            happens here if the emitter is undefined, which is more cumbersome\n            than what it's worth. */\n          options?.eventEmitter?.emit(EVENTS.SESSION_EXPIRED);\n        }\n      }\n    };\n    latestTimeout = setTimeout(\n      proactivelyRefreshToken,\n      // If currentRefreshOptions is defined, options is necessarily defined too.\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      computeRefreshDelay(options!.expiresIn) * 1000\n    );\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    options!.eventEmitter?.emit(EVENTS.TIMEOUT_SET, latestTimeout);\n  } else if (options !== undefined && options.eventEmitter !== undefined) {\n    // If no refresh options are provided, the session expires when the access token does.\n    const expirationTimeout = setTimeout(() => {\n      // The event emitter is always defined in our code, and it would be tedious\n      // to test for conditions when it is not.\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      options.eventEmitter!.emit(EVENTS.SESSION_EXPIRED);\n    }, computeRefreshDelay(options.expiresIn) * 1000);\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    options.eventEmitter!.emit(EVENTS.TIMEOUT_SET, expirationTimeout);\n  }\n  return async (url, requestInit?): Promise<Response> => {\n    let response = await makeAuthenticatedRequest(\n      unauthFetch,\n      currentAccessToken,\n      url,\n      requestInit,\n      options?.dpopKey\n    );\n\n    const failedButNotExpectedAuthError =\n      !response.ok && !isExpectedAuthError(response.status);\n    if (response.ok || failedButNotExpectedAuthError) {\n      // If there hasn't been a redirection, or if there has been a non-auth related\n      // issue, it should be handled at the application level\n      return response;\n    }\n    const hasBeenRedirected = response.url !== url;\n    if (hasBeenRedirected && options?.dpopKey !== undefined) {\n      // If the request failed for auth reasons, and has been redirected, we should\n      // replay it generating a DPoP header for the rediration target IRI. This\n      // doesn't apply to Bearer tokens, as the Bearer tokens aren't specific\n      // to a given resource and method, while the DPoP header (associated to a\n      // DPoP token) is.\n      response = await makeAuthenticatedRequest(\n        unauthFetch,\n        currentAccessToken,\n        // Replace the original target IRI (`url`) by the redirection target\n        response.url,\n        requestInit,\n        options.dpopKey\n      );\n    }\n    return response;\n  };\n}\n"]}},"error":null,"hash":"defe749885724ca6ce8f1700b490937a","cacheData":{"env":{}}}