{"id":"node_modules/@inrupt/solid-client-authn-browser/dist/login/oidc/refresh/TokenRefresher.js","dependencies":[{"name":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-browser/dist/login/oidc/refresh/TokenRefresher.js.map","includedInParent":true,"mtime":1652099631559},{"name":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-browser/src/login/oidc/refresh/TokenRefresher.ts","includedInParent":true,"mtime":1652099631843},{"name":"/Users/tdrave/demo-solid-app/package.json","includedInParent":true,"mtime":1652099771977},{"name":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-browser/package.json","includedInParent":true,"mtime":1652099631546},{"name":"@inrupt/solid-client-authn-core","loc":{"line":3,"column":42,"index":119},"parent":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-browser/dist/login/oidc/refresh/TokenRefresher.js","resolved":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-core/dist/index.js"},{"name":"@inrupt/oidc-client-ext","loc":{"line":4,"column":34,"index":189},"parent":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/solid-client-authn-browser/dist/login/oidc/refresh/TokenRefresher.js","resolved":"/Users/tdrave/demo-solid-app/node_modules/@inrupt/oidc-client-ext/dist/index.es.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst solid_client_authn_core_1 = require(\"@inrupt/solid-client-authn-core\");\nconst oidc_client_ext_1 = require(\"@inrupt/oidc-client-ext\");\nclass TokenRefresher {\n    constructor(storageUtility, issuerConfigFetcher, clientRegistrar) {\n        this.storageUtility = storageUtility;\n        this.issuerConfigFetcher = issuerConfigFetcher;\n        this.clientRegistrar = clientRegistrar;\n    }\n    async refresh(sessionId, refreshToken, dpopKey, eventEmitter) {\n        const oidcContext = await (0, solid_client_authn_core_1.loadOidcContextFromStorage)(sessionId, this.storageUtility, this.issuerConfigFetcher);\n        const clientInfo = await this.clientRegistrar.getClient({ sessionId }, oidcContext.issuerConfig);\n        if (refreshToken === undefined) {\n            throw new Error(`Session [${sessionId}] has no refresh token to allow it to refresh its access token.`);\n        }\n        if (oidcContext.dpop && dpopKey === undefined) {\n            throw new Error(`For session [${sessionId}], the key bound to the DPoP access token must be provided to refresh said access token.`);\n        }\n        const tokenSet = await (0, oidc_client_ext_1.refresh)(refreshToken, oidcContext.issuerConfig, clientInfo, dpopKey);\n        if (tokenSet.refreshToken !== undefined) {\n            eventEmitter === null || eventEmitter === void 0 ? void 0 : eventEmitter.emit(solid_client_authn_core_1.EVENTS.NEW_REFRESH_TOKEN, tokenSet.refreshToken);\n            await this.storageUtility.setForUser(sessionId, {\n                refreshToken: tokenSet.refreshToken,\n            });\n        }\n        return tokenSet;\n    }\n}\nexports.default = TokenRefresher;\n"},"sourceMaps":{"js":{"version":3,"file":"TokenRefresher.js","sourceRoot":"","sources":["../../../../src/login/oidc/refresh/TokenRefresher.ts"],"names":[],"mappings":";;AA0BA,6EAUyC;AACzC,6DAAkD;AAUlD,MAAqB,cAAc;IACjC,YACU,cAA+B,EAC/B,mBAAyC,EACzC,eAAiC;QAFjC,mBAAc,GAAd,cAAc,CAAiB;QAC/B,wBAAmB,GAAnB,mBAAmB,CAAsB;QACzC,oBAAe,GAAf,eAAe,CAAkB;IACxC,CAAC;IAEJ,KAAK,CAAC,OAAO,CACX,SAAiB,EACjB,YAAqB,EACrB,OAAiB,EACjB,YAA2B;QAE3B,MAAM,WAAW,GAAG,MAAM,IAAA,oDAA0B,EAClD,SAAS,EACT,IAAI,CAAC,cAAc,EACnB,IAAI,CAAC,mBAAmB,CACzB,CAAC;QAEF,MAAM,UAAU,GAAY,MAAM,IAAI,CAAC,eAAe,CAAC,SAAS,CAC9D,EAAE,SAAS,EAAE,EACb,WAAW,CAAC,YAAY,CACzB,CAAC;QAEF,IAAI,YAAY,KAAK,SAAS,EAAE;YAE9B,MAAM,IAAI,KAAK,CACb,YAAY,SAAS,iEAAiE,CACvF,CAAC;SACH;QAED,IAAI,WAAW,CAAC,IAAI,IAAI,OAAO,KAAK,SAAS,EAAE;YAC7C,MAAM,IAAI,KAAK,CACb,gBAAgB,SAAS,0FAA0F,CACpH,CAAC;SACH;QAED,MAAM,QAAQ,GAAG,MAAM,IAAA,yBAAO,EAC5B,YAAY,EACZ,WAAW,CAAC,YAAY,EACxB,UAAU,EACV,OAAO,CACR,CAAC;QAEF,IAAI,QAAQ,CAAC,YAAY,KAAK,SAAS,EAAE;YACvC,YAAY,aAAZ,YAAY,uBAAZ,YAAY,CAAE,IAAI,CAAC,gCAAM,CAAC,iBAAiB,EAAE,QAAQ,CAAC,YAAY,CAAC,CAAC;YACpE,MAAM,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,SAAS,EAAE;gBAC9C,YAAY,EAAE,QAAQ,CAAC,YAAY;aACpC,CAAC,CAAC;SACJ;QACD,OAAO,QAAQ,CAAC;IAClB,CAAC;CACF;AApDD,iCAoDC","sourcesContent":["/*\n * Copyright 2022 Inrupt Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n * Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * @hidden\n * @packageDocumentation\n */\n\nimport {\n  IClient,\n  IClientRegistrar,\n  IIssuerConfigFetcher,\n  IStorageUtility,\n  loadOidcContextFromStorage,\n  KeyPair,\n  ITokenRefresher,\n  TokenEndpointResponse,\n  EVENTS,\n} from \"@inrupt/solid-client-authn-core\";\nimport { refresh } from \"@inrupt/oidc-client-ext\";\nimport { EventEmitter } from \"events\";\n\n// Some identifiers are not in camelcase on purpose, as they are named using the\n// official names from the OIDC/OAuth2 specifications.\n/* eslint-disable camelcase */\n\n/**\n * @hidden\n */\nexport default class TokenRefresher implements ITokenRefresher {\n  constructor(\n    private storageUtility: IStorageUtility,\n    private issuerConfigFetcher: IIssuerConfigFetcher,\n    private clientRegistrar: IClientRegistrar\n  ) {}\n\n  async refresh(\n    sessionId: string,\n    refreshToken?: string,\n    dpopKey?: KeyPair,\n    eventEmitter?: EventEmitter\n  ): Promise<TokenEndpointResponse> {\n    const oidcContext = await loadOidcContextFromStorage(\n      sessionId,\n      this.storageUtility,\n      this.issuerConfigFetcher\n    );\n    // This should also retrieve the client from storage\n    const clientInfo: IClient = await this.clientRegistrar.getClient(\n      { sessionId },\n      oidcContext.issuerConfig\n    );\n\n    if (refreshToken === undefined) {\n      // TODO: in a next PR, look up storage for a refresh token\n      throw new Error(\n        `Session [${sessionId}] has no refresh token to allow it to refresh its access token.`\n      );\n    }\n\n    if (oidcContext.dpop && dpopKey === undefined) {\n      throw new Error(\n        `For session [${sessionId}], the key bound to the DPoP access token must be provided to refresh said access token.`\n      );\n    }\n\n    const tokenSet = await refresh(\n      refreshToken,\n      oidcContext.issuerConfig,\n      clientInfo,\n      dpopKey\n    );\n\n    if (tokenSet.refreshToken !== undefined) {\n      eventEmitter?.emit(EVENTS.NEW_REFRESH_TOKEN, tokenSet.refreshToken);\n      await this.storageUtility.setForUser(sessionId, {\n        refreshToken: tokenSet.refreshToken,\n      });\n    }\n    return tokenSet;\n  }\n}\n"]}},"error":null,"hash":"4a76814a41cd864935fa5dd1e093df92","cacheData":{"env":{}}}